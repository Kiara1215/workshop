# 算法思想



## 1. 递归

Q：给定一个用户ID，如何找到这个用户的"最终推荐人"？

A：递归



1. 如何理解递归？
    * 举例：电影院中，向前面人问自己处在哪一排；
    * 分解过程：去的过程叫"递"，回来的过程叫"归"；
2. 递归需要满足的三个条件：
    * 一个问题可以分解为几个子问题的解；
    * 这个问题与分解后的子问题，除了数据规模不同外，求解思路完全一样；
    * 存在递归终止条件；
3. 如何编写递归代码？(写出递推公式，找到终止条件！)
    * 步骤：
        * 找到如何将大问题分解为小问题的规律，并基于此写出递推公式；
        * 然后敲定终止条件；
        * 将递推公式和终止条件翻译成代码；
    * Note：
        * 不要试图用人脑去分解递归的展开；
        * 假设子问题已经解决，在此基础上思考如何解决问题；
4. 递归代码要警惕堆栈溢出：
    
    * 限制递归调用的最大深度；(但不是很实用)
5. 递归代码要警惕重复计算：
    
    * 为了避免重复计算，可以通过一个散列表来保存已经求解过的f(k)。当递归调用到f(k)时，先看是否已经求解过。如果是，则直接从散列表中取值返回，不重复计算；(以空间换时间的思想)
6. 怎样将一个递归代码改写为非递归代码？
    
    * 所有的递归代码都可以改为迭代循环的非递归写法；
7. 递归的特点：
    * 优点：逻辑简单，代码简洁；
    * 缺点：堆栈溢出、重复计算、函数调用耗时多、空间复杂度高；
8. 递归的四条基本法则：(From <<数据结构与算法分析(C语言实现)>>)
    * 基准情形：总存在某些基准情形，不需要递归就能解；
    * 不断推进：每一次递归调用都必须朝基准情形推进；
    * 设计法则：假设所有递归调用都能进行；
    * 合成效益法则：切勿在不同的递归调用中做重复性的工作；
9. 常见的递归示例：
    * 阶乘：
    
        * 递归实现：
    
            ```C++
            long long factorial(int n)
            {
                if(n == 1) return 1;
                return factorical(n-1)*n;
            }
            ```
    
        * 迭代实现：
    
            ```C++
            long long factorical(int n)
            {
                long long fac = 1;
                for(int i = 1; i <= n; i++)
                    fac *= n;
                
                return fac;
            }
            ```
    
    * Fibonacci数列(青蛙跳台阶)：
    
        * 递归实现：
    
            ```C++
            // f(1) = 1, f(2) = 1, f(n) = f(n-1) + f(n-2) (n > 2)
            
            int fibonacci(int n)
            {
                if(n == 1) return 1;
                if(n == 2) return 1;
                
                return fibonacci(n-1) + fibonacci(n-2);
            }
            ```
    
        * 迭代实现：
    
            ```C++
            int fibonacci(int n)
            {
                if(n == 1) return 1;
                if(n == 2) return 1;
                
                int res = 0;
                int prepre = 1;
                int pre = 1;
                for(int i = 3; i <= n; i++)
                {
                    res += pre + prepre;
                    prepre = pre;
                    pre = res;
                }
                
                return res;
            }
            ```
    
    * 汉诺塔(hanoi)：
    
    * 组合数：
    
    * 树的遍历：
    
    * 全排列：