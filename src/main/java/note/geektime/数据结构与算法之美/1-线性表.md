# 线性表

[TOC]

## 1. 数组：

Q：为什么大多数编程语言中，数组要从0开始编号？

A：第一，数组下标表示偏移量，从0开始编号使寻址计算更容易；第二，历史原因，受C语言影响；



1. 如何实现随机访问？

    * 定义：

        * 数组(Array)是一种线性表，它用一组连续的内存空间，来存储一组具有相同类型的数据；

    * 线性表 & 非线性表：
        * 线性表：数组、链表、栈、队列；
        * 非线性表：树、图；
        
    * 连续内存空间 & 相同数据类型：
      
        * 随机访问；(数组支持随机访问，根据下标随机访问数组元素的时间复杂度为O(1))
        
        * 寻址公式：
        
            ```C++
            a[i]_address = base_address + i * data_type_size
            ```

2. 低效的插入和删除：

    * 插入：
        * 时间复杂度：
            * 最好O(1)：尾部插入；
            * 最坏O(n)：头部插入；
            * 平均O(n)：任意位置插入；
        * 特殊情况下的技巧：
            * 搬移 + 插入；(参考课程)
            * 可以将时间复杂度降低为O(1)；
    * 删除：
        * 时间复杂度：
            * 最好O(1)：头部删除；
            * 最坏O(n)：尾部删除；
            * 平均O(n)：任意位置删除
        * 特殊情况下的技巧：
            * 标记删除法(JVM标记清除垃圾回收算法的核心思想)；
                * 先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除；当数组空间不足时，再触发一次真正的删除操作；可以提升效率；
                * (类比生活中的垃圾桶)将垃圾丢入垃圾桶，等到垃圾桶满了，再将垃圾桶中的垃圾倒了；

3. 警惕数组的越界访问问题：

    * 系统内存的分配：栈从高地址开始分配；(Linux系统)

4. 容器能否完全替代数组？

    * 举例：Java中ArrayList
        * 优势：将很多数组操作的细节封装起来；支持动态扩容(1.5倍)；
        * 注意：因为扩容比较耗时，使用时最好能先指定数组大小；
    * 建议：
        * 对于业务开发，使用容器就足够了，虽然会损失一点点性能；
        * 对于底层开发，使用数组，将性能的优化做到极致；



## 2. 链表(上)

Q：如何用LRU来实现缓存淘汰策略？

A：有序链表 or 散列表



Q：如果字符串是通过单链表来存储的，如何判断一个字符串是否是回文串？

A：

* 算法思路：

    * 快慢指针寻找链表中点，同时将前半部分链表反转；
    * 一个指针向后走、一个指针向前走，判断其对应的值是否相等；
    * 注意链表长度可能为奇数或者偶数，若为奇数，需要将满指针向后再移动一位；

* Codes：

    ```C++
    // com.geeklee.data_structure_algorithm.leetcode 234
    
    bool isPalindrome(ListNode* head)
    {
        // 快慢指针寻找链表中点，并将前半部分链表反转
        ListNode* fast = head;
        ListNode* slow = head;
        ListNode* prev = nullptr;
        while(fast != nullptr && fast->next != nullptr)
        {
            fast = fast->next->next;
            
            ListNode* next = slow->next;
            slow->next = prev;
            prev = slow;
            slow = next;
        }
        
        // 若链表长度为奇数，慢指针向后移动一位，跳过中间节点
        if(fast != nullptr) slow = slow->next;
        
        // prev指针与slow指针分别向前、向后移动，比较其对应的值是否相等
        while(slow != nullptr)
        {
            if(slow->val != prev->val) return false;
            slow = slow->next;
            prev = prev->next;
        }
        
        return true;
    }
    ```



1. 存储结构：

    * 数组：需要一块连续的内存空间来存储；
    * 链表：用"指针"将一组零散的内存块串联起来，不需要连续的内存空间；

2. 分类：

    * 单链表：

        * 每个结点不仅有数据域data，还有一个指向下一个结点的指针next，通过指针串联零散的内存空间；
        * 尾指针指向NULL；

        * 插入：仅要考虑相邻结点指针的改变，O(1)；
        * 随机访问第k个结点：需要从头开始依次遍历，O(n)；

    * 循环链表：

        * 是一种特殊的单链表，尾指针指向头结点；

        * 从链头到链尾比较方便；

            (当要处理的数据具有环形特点时，特别适合采用循环链表。比如：约瑟夫环问题)

    * 双链表：

        - 每个结点不仅有后继指针next，还有前驱指针prev，指向前一个结点；
        - 占用内存比单链表要大，但同时插入、删除等操作更灵活，所以实际应用广泛；

3. 数组 & 链表：

    * 数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU缓存机制，预读数组中的数据，所以访问效率更高；而链表在内存中并不是连续存储，对CPU缓存不友好，没办法有效预读；
    * 链表本身没有大小限制，天然支持动态扩容，更适合删除、插入操作频繁的场景，查询的复杂度较高；



## 3. 链表(下)

Q：如何轻松写出正确的链表代码？

A：6点建议



1. 理解指针或引用的含义：

2. 警惕指针丢失和内存泄露：

    * 插入、删除结点时，一定要注意操作的顺序；
    * 删除链表结点时，一定要注意手动释放内存空间；

3. 利用哨兵简化实现难度：

    * 在头结点前插入一个不含数据的结点，称为哨兵结点；

        (一般在需要对链表的头结点进行相关操作时，此方法可简化实现难度，不需要为头节点单独编写代码)

4. 重点留意边界条件的处理：

    * 链表为空时；
    * 链表只含一个结点时；
    * 链表只包含两个结点时；
    * 代码逻辑在处理链表的头、尾结点时能否正常工作；

5. 举例画图，辅助思考：

6. 多写多练，没有捷径：

    * 单链表反转；
    * 链表中环的检测；
    * 两有序链表的合并；
    * 删除链表倒数第k个结点；
    * 求链表的中间结点；



## 4. 栈

Q：如何实现浏览器的前进后退功能？

A：使用两个栈



1. 如何理解栈？

    * 举例：餐厅里面的一摞盘子，只能从上面放，也只能从上面取；
    * 特点：后进先出LIFO(Last In First Out)；
    * 实质：一种"操作受限"的线性表，只允许在一端插入和删除数据；
    * 基本操作：入栈、出栈；

2. 如何实现一个栈？

    * 顺序栈：基于数组实现

        ```C++
        
        ```

    * 链式栈：基于链表实现(链表头为栈顶)

        ```C++
        
        ```

3. 栈操作：

    * 创建：
    * 入栈：push()
    * 出栈：pop()
    * 访问栈顶元素：top()
    * 销毁：

4. 复杂度分析：

    * 空间复杂度：O(1)；在入栈、出栈过程中，只需要一两个临时变量的存储空间；
    * 时间复杂度：O(1)；在入栈、出栈过程中，只涉及栈顶个别元素的操作；

5. 支持动态扩容的顺序栈：

    * 需要底层依赖一个动态扩容的数组；
    * 在开发中不常用，重点掌握复杂度分析；

6. 栈在函数调用中的应用：

    * 函数调用的特点：越早发生的调用越晚返回；

    * 函数调用：将该函数的栈帧压入栈；(栈指针：指向栈顶；帧指针：指向栈底)
    * 函数返回：将该函数的栈帧弹出栈；

7. 栈在表达式求值中的应用：

    * 操作数栈：遇到数字直接压入操作数栈；
    * 操作符栈：遇到操作符，将其与栈顶操作符比较。若比栈顶操作符优先级高，将当前操作符压入栈；若比栈顶操作符优先级低或者相同，从操作符栈取栈顶操作符，同时从操作数栈取两个操作数，然后进行计算，将计算结果压入操作数栈，然后继续比较。直到表达式结束，然后清空操作数栈和操作符栈；

8. 栈在括号匹配中的应用：

    * Steps：
    
        * 用栈来保存未匹配的左括号，从左到右依次扫描字符串；
        * 当扫描到左括号时，将其压入栈中；
        * 当扫描到右括号时，取出栈顶括号。若不能匹配，失败；若能匹配，继续扫描；
    
    * Codes：
    
        ```C++
        // com.geeklee.data_structure_algorithm.leetcode 20
        
        bool isVaild(string s)
        {
            map<char, char> mp;
            mp[')'] = '(';
            mp[']'] = '[';
            mp['}'] = '{';
        
            stack<char> s;
            for(char c : s)
            {
                if(mp.count(c))
                {
                    if(s.empty() || mp[c] != s.top()) return false;
                    else s.pop();
                }
                else
                    s.push(c);
            }
        
            return s.empty();
        }
        ```



## 5. 队列

Q：当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，该如何处理这个请求？

A：非阻塞队列(拒绝请求)；阻塞队列(请求排队，先来先服务)；



1. 如何理解队列？
    * 举例：排队买票(先来的先买，后来的只能站在末尾排队，不能插队)；
    * 特点：先进先出FIFO(First In First Out)；
    * 实质：一种操作受限的线性表，只能从队头出队，从队尾入队；
    * 基本操作：入队、出队；
    
2. 如何实现队列？
    * 顺序队列：用数组实现；
        * 队空条件：head == tail；
        
        * 队满条件：tail == n；
        
        * 当队满时，需要进行数据搬移，将head~tail之间的数据整体搬移到数组中0~tail-head的位置；
        
        * Codes：
        
            ```C++
            
            ```
    * 链式队列：用链表实现；
        * 入队操作：tail->next = new_node, tail = tail->next；
        
        * 出队操作：head = head->next；
        
        * Codes：
        
            ```C++
            
            ```
    
3. 循环队列：
    * 目的：将数组首尾相连，避免数据搬移；
    
    * 队空条件：head == tail；
    
    * 队满条件：(tail + 1)%n == head；
    
    * Codes：(这种实现方式会造成一个数组元素空间的浪费)
    
        ```C++
        
        ```
    
    * 第二种实现方式：
    
        * 定义一个记录队列中元素个数的值size：
    
            * 当size == capacity时，表示队列已满；
            * 当size == 0时，表示队列为空；
    
        * Codes：
    
            ```C++
            
            ```
    
4. 阻塞队列和并发队列：

    * 阻塞队列：
        * 在一般队列的基础上增加了阻塞操作：
            * 当队列为空时，从队头取元素会被阻塞；
            * 当队列为满时，向队尾插入元素会被阻塞；
        * 实质：典型的"生产者-消费者模型"；
    * 并发队列：
        * 定义：线程安全的队列叫并发队列；
        * 实现：
            * enqueue(), dequeue()方法上加锁；(锁粒度大会导致并发度降低)
            * 基于数组的循环队列，用CAS原子操作，可实现非常高效的并发队列；