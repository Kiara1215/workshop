# 图

[TOC]

## 30. 图的表示

Q：如何存储微信、微博等社交网络中的好友关系？

A：

* 微信：无向图；
* 微博：有向图；
* QQ：带权图；



1. 如何理解图？
    * 概念：
        * 树(Tree)和图(Graph)都属于非线性表数据结构，图更为复杂；
        * 树中的元素称为节点，图中的元素称为顶点(vertex)；
        * 图中的一个顶点可以与任意其他顶点建立连接关系，这种连接称为边(edge)；
        * 与顶点相连的边的条数，称为顶点的度(degree)；
    * 分类：
        * 无向图：微信(添加好友是双向的)
        * 有向图：微博(允许单向关注)；入度(in-degree)和出度(out-degree)；
        * 带权图：QQ亲密度(每条边都有一个权重(weight)，用来表示QQ好友间的亲密度)；
2. 存储方法：
    * 邻接矩阵(Adjacency matrix)：
        * 思想：
            * 底层依赖一个二维数组；
        * 具体做法：
            * 无向图：如果顶点i与j之间有边，将$A[i][j]$与$A[j][i]$都标记为1；
            * 有向图：如果顶点i到顶点j之间，有一条从顶点i指向顶点j的边，将$A[i][j]$标记为1；
            * 带权图：数组中存储相应的权重；
        * 特点：
            * 简单、直观：
                * 首先，因为基于数组，所以能很高效地获取两个顶点之间的关系；
                * 其次，可以将很多图之间的运算转换为矩阵之间的运算；(Floyd-Warshall算法求最短路径)
            * 比较浪费内存空间：
                * 对于无向图来说，如果$A[i][j]$是1，那么$A[j][i]$也是1，只需要存储一个就可以；(对称矩阵)
                * 对于稀疏图(sparse matrix)，顶点很多，但每个顶点的边不多，会更加浪费内存；
    * 邻接表(Adjacency list)：
        * 思想：
            * 与散列表类似；
        * 具体做法：
            * 每个顶点对应一条链表，链表中存储的是与这个顶点相连的其他顶点；
        * 特点：
            * 节约内存空间，但使用起来比较耗费时间；(时间、空间复杂度的平衡)



## 31. 深度和广度优先搜索

Q：给你一个用户，如何找出这个用户的所有三度(其中包含一度、二度和三度)好友关系？(可能认识的人)

A：



1. 广度优先搜索(breadth first search, bfs)：

    * 含义：

        * 一种"地毯式"的层层推进的搜索策略，先查找离起点最近的，然后是次近的，依次往外搜索；

    * 实现策略：

        * 借助队列(与二叉树的层次遍历类似，其实二叉树的层次遍历就是广度优先搜索)；

    * 实现：

        ```C++
        
        ```

    * 复杂度分析：

        * 时间复杂度：O(E)
        * 空间复杂度：O(V)

2. 深度优先算法(depth first search, dfs)：

    * 含义：

        * 与"走迷宫"类似：走一条路发现不同，退回上一个岔路口，重新选择一条路继续走，直到找到出口；

    * 算法思想：

        * 回溯；

    * 实现策略：

        * 递归；(显示递归或者借用栈)

    * 实现：

        * 递归：

            ```C++
            
            ```

        * 借助栈：

            ```C++
            
            ```

    * 复杂度分析：

        * 时间复杂度：O(E)；(每条边最多被访问两次，一次是遍历，一次是回退)
        * 空间复杂度：O(V)；