[TOC]

# 进程的描述与控制

## 2.1 前趋图与程序的执行

### 2.1.1 前趋图(Precedence Graph)

1. 作用：用来描述进程之间执行的先后顺序；
2. 描述：$P_i \to P_j$，表示在$P_j$开始执行之前$P_i$必须完成；
3. Note：前趋图中是不允许有循环的，否则必然会产生不可实现的前趋关系。



### 2.1.2 程序的顺序执行

1. 程序的顺序执行：
   * 一道作业的“输入、计算、输出”；
2. 程序顺序执行时的特征：
   * 顺序性：每一操作必须在下一个操作开始前结束；
   * 封闭性：程序运行时独占全机资源，执行结果不受外界因素影响；
   * 可再现性：重复执行时能得到相同的结果；



### 2.1.3 程序的并发执行

1. 程序的并发执行：
   * 一批作业的“输入、计算、输出”；
2. 程序并发执行时的特征
   * 间断性："执行—暂停—执行"，由并发执行的程序之间的相互制约关系导致；
   * 失去封闭性：任一程序在执行时，其环境必然受到其他进程的影响；
   * 不可再现性：由于失去封闭性导致，其结果与并发进程的执行速度有关；



## 2.2 进程的描述

### 2.2.1 进程的定义和特征

1. 进程的定义：
   * 目的：为了使程序能并发执行，并且可以对并发执行的程序加以描述和控制；
   * 进程控制块(PCB，Process Control Block)：一个专门的数据结构，用来描述进程的基本情况和活动过程；
   * 进程(进程实体) = 程序段 + 数据段 + PCB；
   * 定义(传统OS中的进程)：进程是进程实体的运行过程，是系统进行资源分配和调度的基本单位；

2. 进程的特征(**进程和程序是两个截然不同的概念**)：
   * PCB：进程具有PCB结构，程序不具有PCB结构；
   * 动态性：进程是动态的，程序是静态的；
     * 进程由创建而产生，由调用而执行，由撤销而消亡；
     * 程序是一组有序指令的集合，并存放于某种介质上；
   * 并发性：进程可以并发执行，程序不可以并发执行(或者说程序并发执行没有意义)；
   * 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位，程序不能作为独立单位运行；
   * 异步性：进程按照异步方式运行(为了保证结果的可再现性，配置了进程同步机制)；



### 2.2.2 进程的基本状态及转换

1. 进程的三种基本状态：
   * 就绪(ready)：准备好运行的状态(已分配到除CPU外所有必要的资源)；
   * 执行(running)：已经获得CPU，正在执行；
   * 阻塞(block)：正在执行的进程由于发生某事件(比如：IO等)而暂时无法继续执行的状态；
2. 三种基本状态的转换：(就绪状态与执行状态可以互相转化)
   * 就绪 —— 执行(进程调度)
   * 执行 —— 就绪(时间片完)
   * 执行 —— 阻塞(I/O请求)
   * 阻塞 —— 就绪(I/O完成)
3. 创建状态和终止状态：
   * 创建状态：
     * 进程的创建过程：
       * 由申请一个空白PCB，并向PCB中写入用于控制和管理进程的信息；
       * 为该进程分配资源；
       * 将该进程转入就绪状态，并插入就绪队列中；
     * 创建状态：进程所需的资源尚不能得到满足，创建工作尚未完成的状态；
   * 终止状态：
     * 进程的终止过程：
       * 等待操作系统进行善后处理；
       * 将其PCB清零，并将PCB空间返还给系统；



### 2.2.3 挂起操作和激活操作(suspend & active)

1. 挂起操作的引入：
   * 终端用户的需要；
   * 父进程的请求；
   * 负荷调节的需要；
   * 操作系统的需要；
2. 引入挂起操作后三个进程状态的转换：
   * suspend : 活动就绪(readya) —— 静止就绪(readys)
   * suspend : 活动阻塞(blockeda) —— 静止阻塞(blockeds)
   * active : 静止就绪(readys) —— 活动就绪(readya)
   * active : 静止阻塞(blockeds) —— 活动阻塞(blockeda)
3. 引入挂起操作后五个进程状态的转换：
   * NULL —— 创建；
   * 创建 —— 活动就绪；
   * 创建 —— 静止就绪；
   * 执行 —— 终止；



### 2.2.4 进程管理中的数据结构

1. 操作系统用于管理控制的数据结构：

   * **操作系统将各类资源(包括硬件和信息)抽象为数据结构，方便使用和管理**
   * 分类：
     * 内存表
     * 设备表
     * 文件表
     * 进程表

2. 进程控制块PCB的作用：

   * 作为独立运行基本单位的标志；

   * 能实现间断性运行方式；

       (系统将CPU现场信息保存在被中断进程的PCB中，供该进程再次被调度执行时恢复CPU现场时使用)

   * 提供进程的管理、调度、同步、通信等所需要的信息；

3. 进程控制块中的信息

   * 进程标识符(用于唯一的标识一个进程)：

     * 外部标识符：(相当于一个人的名字。不唯一，方便用户。)

     * 内部标识符：(相当于一个人的身份证号。唯一，方便系统。)

   * 处理机状态：

     * 处理机的状态信息也称处理机的上下文，主要是处理机的各种寄存器的内容所组成；

     * 当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时能再从断点继续执行；

   * 进程调度信息：

     * 进程状态

     * 进程优先级

     * 进程调度所需其他信息

     * 事件(阻塞原因)

   * 进程控制信息：

     * 程序和数据的地址
     * 进程同步和通信机制
     * 资源清单
     * 链接指针

4. 进程控制块的组织方式：

   * 线性方式(将所有的PCB都组织在一张线性表中)
       * 优点：实现简单、开销小；
       * 缺点：每次查找需要扫描整张表(适合进程数目不多的系统)；
   * 链接方式(将状态相同的PCB通过PCB的链接字链接成一个队列，形成就绪、阻塞、空白队列等)
       * 相当于链表；
   * 索引方式(根据所有进程状态的不同建立几张索引表)
       * 相当于静态链表(用数组实现的链表)；



## 2.3 进程控制

### 2.3.1 操作系统内核

1. OS内核：将一些与硬件紧密相关的模块、各种常用设备的驱动程序、运行频率较高的模块，都安排在紧靠硬件的软件层次中，将它们常驻内存，称为OS内核。
2. 目的：
   * 保护这些软件；
   * 提高OS运行效率；
3. 处理机状态：
   * 系统态(管态，内核态)：具有较高的权限，传统OS都在系统态运行；
   * 用户态(目态)：具有较低的权限，应用程序一般都在用户态运行；
4. OS内核的功能：
   * 支撑功能：
     * 中断管理：
     * 时钟管理：
       * 时间片轮转调度；
       * 实时系统中的截止时间控制
       * 批处理系统中的最长运行时间控制
     * 原语操作：
       * 原语(Primitive)：该操作中的所有动作要么全做，要么全不做，在执行过程中不允许被中断。即原子操作(Atomic Operation)；
   * 资源管理功能：
     * 进程管理
     * 存储器管理
     * 设备管理



### 2.3.2 进程的创建

1. 进程的层次结构：

   * 形成：在OS中，允许一个进程创建另一个进程(父进程&子进程)；
   * 特点：

     * 子进程可以继承父进程所有的资源，父进程不能拒绝；

     * 子进程撤销时，将从父进程那里获得的资源归还给父进程；

     * 撤销父进程时，也必须同时撤销其所有的子进程；
   * **Note：Unix中存在进程的层次关系，而Windows中不存在。在windows中进程间通过句柄相互控制；**
   * 孤儿进程：
       * 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程；
       * 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作；
       * 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害；
   * 僵尸进程：
       * 一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程；
       * 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）；
       * 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程；
       * 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程；

2. 进程图：

   * 进程图(Process Graph)：用于描述进程间关系的一棵有向树；
   * 父进程(Parent Process)：
   * 子进程(Progeny Process)：

3. 引起进程创建的事件

   * 用户登陆
   * 作业调度
   * 提供服务
   * 应用请求

4. 进程的创建过程(Create原语)

   * 申请空白PCB
   * 分配资源
   * 初始化PCB
   * 加入就绪队列



### 2.3.3 进程的终止

1. 引起进程终止(Termination of Process)的事件
   * 正常结束：
   * 异常结束：
   * 外界干预：
2. 进程终止的过程：
   * 根据被终止进程的标识符，检索该进程的PCB；
   * 终止该进程及其子孙进程；
   * 归还资源给操作系统；
   * 将其从列表中移除



### 2.3.4 进程的阻塞与唤醒(block & wakeup)

1. 引起进程阻塞与唤醒的事件：
   * 向系统请求共享资源失败；
   * 等待某种操作的完成；
   * 新数据尚未到达；
   * 等待新任务到达；
2. 进程阻塞过程(block原语)：
   * 根据阻塞原因，加入不同的阻塞队列；(主动行为)
3. 进程唤醒过程(wakeup原语)：
   * 将该进程从阻塞队列中移出；
   * 将其PCB中的现行状态由阻塞改为就绪；
   * 将该PCB插入就绪队列中；



### 2.3.5 进程的挂起与激活(suspend & active)

1. 进程的挂起(suspend原语)：

   * 检查被挂起进程的状态；
   * 改变状态；(活动阻塞 —— 静止阻塞；活动就绪 —— 静止就绪；执行 —— 调度)

2. 进程的激活(active原语)：

   * 从外存调入内存；
   * 检查状态；
   * 改变状态；(静止... —— 活动...)

   **抢占调度策略：**每当有静止就绪进程被激活而插入就绪队列时，便检查是否要进行重新调度。(由调度程序将被激活进程的优先级与当前进程的优先级进行比较，......)



## 2.4 进程同步

**概述：通过加锁的方式，保证程序执行的可再现性。(测试和关锁操作必须是连续的)**

**(单处理机中)进程同步机制：硬件同步机制、信号量机制、管程机制**



### 2.4.1 进程同步的基本概念

1. 两种形式的制约关系：

   * 间接相互制约关系：多进程共享临界资源；
   * 直接相互制约关系：进程间的相互合作；

2. 临界资源(Critical Resouce)：只能互斥访问，并且不可被抢占的资源；

   * 硬件临界资源；
   * 软件临界资源；

3. 临界区：

   * 进入区(Entry Section)：检查临界资源是否被访问；

   * 临界区(Critical Section)：访问临界资源的代码段；

   * 退出区(Exit Section)：恢复临界资源为未被访问；

   * 剩余区(Remain Section)：其他部分的代码；

     ```C++
     // entry section
     // critical section
     // exit section
     // remainder section
     ```

4. 同步机制应遵循的规则

   * 空闲让进
   * 忙则等待
   * 有限等待
   * 让权等待



### 2.4.2 硬件同步机制

1. 关中断：

   * 中断：指进程或线程的调度；

   * 在进入锁测试之前关闭中断，直到完成锁测试并上锁后才能打开中断；
   * 保证了对锁测试和关锁操作的连续性和完整性；
   * 缺点：
     * 滥用关中断权利会导致很严重的后果；
     * 关中断时间过长，会影响系统效率；
     * 不适用于多CPU系统；

2. 利用Test-and-Set指令

   * 描述：

     ```C++
     boolean TS(boolean *lock)
     {
         boolean old;
         old = *lock;
         *lock = TRUE;
         return old;
     }
     ```

   * 利用TS指令实现互斥的循环进程结构：

     ```C++ 
     do
     {
         ...
         while TS(&lock);	/* entry section: 循环测试直到TS(s)为TRUE */
         // critical section;
         lock = FALSE;		/* exit section */
         // remainder section;
     } while(TRUE);
     ```

3. 利用swap指令

   * 描述：

     ```C++
     void swap(boolean *a, boolean *b)
     {
         boolean temp;
         temp = *a;
         *a = *b;
         *b = temp;
     }
     ```

   * 利用swap指令实现进程互斥的循环结构：

     * 语言描述：为每个临界资源设置一个全局的布尔变量lock，其初值为false，在每个进程中再设置一个局部布尔变量key，其初值设为true。在进入临界区前交换二者，测试key的值是否为flase，若是，则进入临界区；若不是，则继续测试直至为flase。

     ```C++
     do
     {
         key = TRUE;
         do
         {
             swap(&lock, &key);
         } while(key != FLASE);
         // critical section;
         lock = FLASE;
         // remainder section;
     } while(TRUE);
     ```

**特点：能实现进程互斥，但当临界资源忙碌时，其他访问进程必须不断地进行测试，不符合“让权等待”的原则。**



### 2.4.3 信号量(Semaphore)机制

1. 整形信号量：

   * 整形信号量：一个用于表征资源数目的整形量S，仅能通过两个标准的原子操作wait(P), signal(S)来操作；

   * wait & signal 操作描述：

     ```C++
     wait(S)		/* 请求一个单位的该类资源 */
     {
         while(S <= 0); 			/* 等待... */
         S--;
     }
     
     signal(S)	/* 释放一个单位的该类资源 */
     {
         S++;
     }
     ```

   * 意义：wait表示请求一个该类型的资源，signal表示释放一个该类型的资源；

   * 特点：不遵循“让权等待”，进程处于“忙等”状态；

2. 记录型信号量(由于采用了记录型的数据结构而得名)：

   * 组成：一个用于代表资源数目的整形变量value + 一个进程链表指针list(用于链接上述的所有等待进程)

   * 数据项描述：

     ```C++
     typedef struct
     {
         int value;
         struct process_control_block *list;
     } semaphore;
     ```

   * wait & signal 操作描述

     ```C++
     /*
     	s->value的初值表示系统中某类资源的数目，因此又称为资源信号量；
     	若s->value的初值为1，表示只允许一个进程访问临界资源，此时信号量转化为互斥信号量；
     */
     
     wait(semaphore *S)		/* 请求一个单位的该类资源 */
     {
         S->value--;
         if(S->value < 0) block(S->list);
         /* 此时s->val的绝对值表示在该信号量链表中已阻塞进程的数目 */
     }
     
     signal(semaphore *S)	/* 释放一个单位的该类资源 */
     {
         S->value++;
         if(S->value <= 0) wakeup(S->list);
     }
     ```

   * 特点：遵循了“让权等待”准则；

3. AND型信号量(在 wait & signal 操作中增加了一个“AND”条件)：

   * 针对的问题：一个进程获得多个共享资源后方能执行；

   * AND同步机制的基本思想：对若干临界资源的分配采用原子操作的方式(要么全都分配，要么全不分配)；

   * Swait & Ssignal (Simultaneous wait & signal) 操作描述：

     ```C++
     Swait(S1, S2, ..., Sn)
     {
         while(TRUE)
         {
             if(Si >= 1 && ... && Sn >= 1)
             {
                 for(i = 1; i <= n; i++) Si--;
                 break;
             }
             else
             {
                 place the process in the waiting queue associated with the first Si
                 found with Si < 1, and set the program count of this process to the
                 beginning of Swait operation
             }
         }
     }
     
     Ssignal(S1, S2, ..., Sn)
     {
         while(TRUE)
         {
             for(i = 1; i <= n; i++)
             {
                 Si++;
                 Remove all the process waiting in the queue associated with Si into
                 the ready queue
             }
         }
     }
     ```

4. 信号量集：

   * 问题描述：一次分配或释放多个资源；分配前确保可分配资源的数目不低于某下限值；

   * 解决方法：(对AND型信号量机制加以扩充)

     * 进程对信号量Si的测试值不再是1，而是该资源分配的下限值ti，即要求Si >= ti；
     * 进程对资源的需求值为di，进行Si = Si - di操作；

   * Swait & Ssignal 的格式：

     ```C++
     Swait(S1, t1, d1, ..., Sn, tn, dn);
     Ssignal(S1, d1, ..., Sn, dn);
     ```

   * 特殊情况：

     * Swait(S, d, d)：信号量集中只有一个信号量S，允许它每次申请d个资源；
     * Swait(S, 1, 1)：退化为一般的记录型信号量(S > 1)或互斥信号量(S = 1)；
     * Swait(S, 1, 0)：当S >= 1时，允许多个进程进入某特定区；当S = 0 时，不允许任何进程进入特定区。相当于一个可控开关；



### 2.4.4 信号量的应用

1. 实现进程互斥：
  
   * 为使多个进程能互斥地访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)之间即可；
   
   * 代码：
   
       ```C++
       semaphore mutex = 1;
       PA()
       {
           while(1)
           {
               wait(mutex);
               // 临界区
               signal(mutex);
               // 剩余区
           }
       }
       
       PB()
       {
           while(1)
           {
               wait(mutex);
               // 临界区
               signal(mutex);
               // 剩余区
           }
       }
       ```
2. 实现前趋关系：
   * 问题描述：两个并发执行的进程P1和P2，P1中有语句S1，P2中有语句S2，希望S1执行后再执行S2。
   * 解决方法：
     * 使进程P1和P2共享一个公用信号量S，并赋初值为0；
     * 在P1中：S1；signal(S)；
     * 在P2中：wait(S)；S2；



### 2.4.5 管程机制

1. 管程(monitor)的定义：
   * 问题描述：每个要访问临界资源的进程都必须自备同步操作wait(S)和signal(S)，使大量的同步操作分散在各个进程中。管理困难，并且容易导致死锁；
   
   * 解决方法：引入管程；
   
   * 目的：对共享资源所有访问统一管理，有效地实现进程互斥；
   
   * 定义：代表共享资源的数据结构以及对该数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块，称之为管程；
   
   * 作用：管程将共享资源抽象，并提供调用接口供使用这些共享资源的进程调用；
   
       * 组成：
   
           * 名称；
           * 代表共享资源的数据结构；
           * 对该结构实施操作的过程；
   
       * 语法描述：
   
           ```C++
           Monitor monitor_name
           {
           	share variable declarations;
           	cond declaration;
           	
           	public:
           		void P1(...)
                   {
                   	...
                   }
                   ...
                   
                   {
                   	initialization code;
                }
           }
           ```
   
       * 管程中包含了面向对象的思想：它将表征共享资源的数据结构及对该数据结构操作的一组过程，都集中封装在一个对象内部，隐藏了实现的细节。
   
* **所有进程要访问临界资源时，都只能通过管程间接访问，而管程每次只允许一个进程进入，执行管程内的过程，从而实现了进程互斥。**
  
   * 管程的特性：
   
  * 模块化：
     * 抽象性：
  * 信息掩蔽：
  
   * 管程和进程的不同：
  
     * 目的：进程是为了实现系统的并发性，管程是为了解决共享资源的互斥使用问题；
     * 数据结构：进程定义的是私有数据结构PCB，管程定义的是共有数据结构(如消息队列)；
  * 工作方式：进程为主动工作方式，管程为被动工作方式；
     * 并发性：进程之间能并发执行，管程不能与其调用者并发执行；
     * 动态性：进程具有动态性，管程是静态的；
  
2. 条件变量：

   * 目的：实现让权等待；
   * 含义：表示进程被阻塞或挂起的原因；
   * 实质：一种抽象数据类型，每个条件变量保存了一个链表，用于记录因该条件变量而阻塞的所有进程。
   * 特点：
     * 一个管程中可以有多个条件变量(因为进程被阻塞或挂起的原因可有多个)；
     * 条件变量的访问只能在管程中进行；
     * 管程中对每个条件变量都予以说明，形式为：condition x,y；
     * 对每个条件变量的操作仅仅是wait和signal，形式为：x.wait 和 x.signal；
     * **与信号量机制中signal操作的不同：signal会使 s = s + 1；而条件变量不会使 s = s + 1；**



## 2.5 经典的进程同步问题

### 2.5.1 生产者-消费者问题(The producer-consumer problem)

**生产者-消费者问题是相互合作的进程关系的一种抽象。**

1. 利用记录型信号量解决：

   * 说明：

     * 假设生产者和消费者之间的共用缓冲池有n个缓冲区；
     * 利用互斥信号量实现诸进程对缓冲池的互斥使用；
     * 利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量；

   * 描述：

     ```C++
     int in = 0, out = 0;
     item buffer[n];
     semaphore mutex = 1, empty = n, full = 0;
     void producer()
     {
         do
         {
         	produce an item nextp;
        		...
        		wait(empty);
         	wait(mutex);
         	buffer[in] = nextp;
         	in = (in + 1) % n;
         	signal(mutex);
         	signal(full);
         } while(TRUE);
     }
     
     void consumer()
     {
         do
         {
             wait(full);
             wait(mutex);
             nextc = buffer[out];
             out = (out + 1) % n;
             signal(mutex);
             signal(empty);
             consume the item in nextc;
             ...
         } while(TRUE);
     }
     
     void main()
     {
         cobegin
             producer(); consumer();
         coend
     }
     ```

   * 注意：

     * 用于实现互斥的 wait(mutex) 和 signal(mutex) 必须成对出现；
     * 对资源信号量 empty 和 full 的 wait 和 signal 操作也必须成对出现，但分别处于不同的程序中；
     * 每个程序中的多个 wait 操作顺序不能错(先对资源信号量的wait，然后对互斥信号量mutex的wait)；

2. 利用AND型信号量解决

   * 思路：用 Swait(empty, mutex) 来代替 wait(empty) 和 wait(mutex)，......

   * 描述：

     ```C++
     int in = 0, out = 0;
     item buffer[n];
     semaphore mutex = 1, empty = n, full = 0;
     void producer()
     {
         do
         {
             produce an item nextp;
         	...
         	Swait(empty, mutex);
         	buffer[in] = nextp;
         	in = (in + 1) % n;
         	Ssignal(mutex, full);
         } while(TRUE);
     }
     
     void consumer()
     {
         do
         {
             Swait(full, mutex);
             nextc = buffer[out];
             out = (out + 1) % n;
             Ssignal(mutex, empty);
             consume the item in nextc;
             ...
         } while(TRUE);
     }
     ```

3. 利用管程解决

   * 说明：

     * put(x)：
     * get(x)：
     * cwait(condition)：
     * csignal(condition)：

   * PC管程描述：

     ```C++
     Monitor producerconsumer
     {
         item buffer[N];
         in in, out;
         condition notfull, notempty;
         int count;
         
         public:
         	void put(item x)
             {
             	if(count >= N) cwait(notfull);
             	buffer[in] = x;
             	in = (in + 1) % N;
             	count++;
             	csignal(notempty);
             }
             
             void get(item x)
             {
             	if(count <= 0) cwait(notempty);
             	x = buffer[out];
             	out = (out + 1) % N;
             	count--;
             	csignal(notfull);
             }
             
         {in = 0; out = 0; count = 0;}
     } PC;
     ```

   * 生产者和消费者描述：

     ```C++
     void producer()
     {
         item x;
         while(TRUE)
         {
             ...
             produce an item in nextp;
             PC.put(x);
         }
     }
     
     void consumer()
     {
         item x;
         while(TRUE)
         {
             PC.get(x);
             consume the item in nextc;
             ...
         }
     }
     
     void main()
     {
         cobegin
             producer(); consumer();
         coend
     }
     ```

     

### 2.5.2 哲学家进餐问题(The dinning philosophers problem)

问题描述：五个哲学家共用一张圆桌，桌上有五个碗和五个筷子，他们交替地进行思考和用餐。一个哲学家饥饿时，便试图取用其左右最靠近他的筷子，只有当他拿到两只筷子时才能进餐。进餐完，放下筷子继续思考。

**哲学家进餐问题是临界资源的一种抽象。**

1. 利用记录型信号量解决：

   * 筷子是临界资源，可以用一个信号量来表示：

     ```C++
     semaphore chopstick[5] = {1, 1, 1, 1, 1};
     ```

   * 第i位哲学家的活动描述：

     ```C++
     do
     {
         wait(chopstick[i]);
         wait(chopstick[(i+1)%5]);
         ...
         // eat
         ...
         signal(chopstick[i]);
         signal(chopstick[(i+1)%5]);
         ...
         // think
         ...
     } while(TRUE);
     ```

   * 问题：可能引发死锁(当5人都拿起左边or右边的筷子时)

   * 解决方案：AND型信号量(当左右两只筷子均可用时，才能拿起吃饭)

2. 利用AND型信号量解决：

   ```C++
   semaphore chopsticks[5] = {1, 1, 1, 1, 1};
   do
   {
       ...
       // think
       ...
       Swait(chopstick[(i+1)%5], chopstick[i]);
       ...
       // eat
       ...
       Ssignal(chopstick[(i+1)%5], chopstick[i]);
   } while(TRUE);
   ```



### 2.5.3 读者-写者问题(The reader-writer problem)

问题描述：一个数据文件可以被多个进程共享：允许多个读进程同时访问一个共享对象，但不允许一个写进程与其他写进程或读进程同时访问一个共享对象。

1. 利用记录型信号量解决：

   ```C++
   semaphore rmutex = 1, wmutex = 1;
   int readcount = 0;
   
   void reader()
   {
       do
       {
           wait(rmutex);
           if(readcount ==0) wait(wmutex);
           readcount++;
           signal(rmutex);
           // perform read operation
           wait(rmutex);
           readcount--;
           if(readcount == 0) signal(wmutex);
           signal(rmutex);
       } while(TRUE);
   }
   
   void Writer()
   {
       do
       {
           wait(wmutex);
           // perform write operation
           signal(wmutex);
       } while(TRUE);
   }
   
   void main()
   {
       cobegin
           Reader(); Writer();
       coend;
   }
   ```

2. 利用信号量集机制解决：

   增加一个限制：最多只允许RN个读者同时读

   解决办法：引入一个新的信号量L，赋初值为RN，通过执行 wait(L, 1, 1) 用于控制读者数目；

   ```C++
   int RN;
   semaphore L = RN, mx = 1;
   
   void Reader()
   {
       do
       {
           Swait(L, 1, 1);		// 控制读者数目
           Swait(mx, 1, 0);	// 相当于一个开关
           // perform read operation
           Ssignal(L, 1);
       } while(TRUE);
   }
   
   void Writer()
   {
       do
       {
           Swait(mx, 1, 1; L, RN, 0);
           // perform write operation
           Ssignal(mx, 1);
       } while(TRUE);
   }
   
   void main()
   {
       cobegin
           Reader(); Writer();
       coend
   }
   ```



## 2.6 进程通信

### 2.6.1 进程通信的类型

​	ps. 进程的互斥与同步称为低级进程通信(虽然有一定的信息交换，但效率低并且通信对用户不透明)。所以通常所说的进程通信指高级进程通信(使用方便、能高效地传递大量数据)。

1. 共享存储器系统(Shared-Memory System)

   * 分类：
     * 基于共享数据的通信方式：低级通信，仅适用于传递少量数据；
     * 基于共享存储区的通信方式：高级通信；
   * 实例：OpenMP；

2. 管道通信系统(pipe)

   * 定义：指用于连接一个读进程和一个写进程，以实现它们之间通信的一个共享文件，又名pipe文件；
   * 特点：
     * 以字符流形式传输数据；
     * 首创于UNIX系统；
     * 能有效地传输大量数据；

3. 消息传递系统(Message Passing System)

   * 分类：直接通信方式、间接通信方式；
   * 实例：MPI(Message Passing Interface)

4. 客户机-服务器系统(Client-Server System)

   * 套接字(socket)：(本地&网络)

     * **套接字是最流行的网络通信程序接口之一**

     * 类型：
       * 基于文件型：本地
       * 基于网络型：网络
     * 优势：不仅适用于同一台计算机内部的进程通信，也适用于网络中不同计算机进程之间的通信；

   * 远程过程调用和远程方法调用：(网络)

     * 远程过程调用RPC(Remote Procedure Call)：一个通信协议，用于通过网络连接的系统；
     * 远程方法调用：如果涉及的软件采用面向对象编程；



### 2.6.2 消息传递通信的实现方式

1. 直接消息传递系统
   * 直接通信原语：
     * 对称寻址方式
     * 非对称寻址方式
   * 消息的格式：
     * 定长消息格式
     * 变长消息格式
   * 进程的同步方式
   * 通信链路
2. 信箱通信
   * 特点：既可以实现实时通信，又可以实现非实时通信；
   * 信箱的结构：
     * 信箱头
     * 信箱体
   * 信箱通信原语：
     * 邮箱的创建和撤销
     * 消息的发送和接收
   * 信箱的类型
     * 私有
     * 共用
     * 共享



### 2.6.3 直接消息传递系统实例

**消息缓冲队列通信方式**

1. 消息缓冲队列通信机制中的数据结构
   * 消息缓冲区
   * PCB中有关通信的数据项
2. 发送原语
3. 接收原语



## 2.7 线程(Threads)的基本概念

### 2.7.1 线程的引入

**目的：**

* 在OS中引入进程，目的是为了是多个程序能并发执行，以提高资源的利用率和系统的吞吐量；
* 在OS中再引入线程，目的是为了减少程序在并发执行时所付出的时空开销，进一步提升OS的并发性；

1. 进程的两个基本属性：
   * 可拥有资源的基本单位；
   * 可独立调度和分派的基本单位；
2. 程序并发执行时所需要付出的时空开销：
   * 创建进程；
   * 撤销进程；
   * 切换进程；
3. 线程：作为调度和分派的基本单位；
   * 思想：将进程的两个属性分开。
     * 不把作为调度和分派的基本单位也同时作为拥有资源的单位；
     * 对于拥有资源的单位，不对之施以频繁的切换；



### 2.7.2 线程与进程的比较

1. 调度的基本单位：

   * 传统OS中，进程是调度的基本单位，在调度时开销较大；

   * 在引入线程的OS中，线程是调度的基本单位，在调度时开销小；

     (线程在切换时仅需要保存和设置少量寄存器内容)

2. 并发性：

   * 线程可并发执行；

3. 拥有资源：

   * 线程本身并不拥有系统资源，仅有一点必不可少的、保证独立运行的资源；(寄存器资源)
   * 多个线程共享进程所拥有的资源；

4. 独立性：

   * 线程的独立性比进程要低很多；(因为多线程共享进程资源)

5. 系统开销：

   * 线程的创建、切换、同步、通信等所需的开销远小于进程；

6. 支持多处理机系统：

   * 传统的系统，即单线程进程，不管有多少处理机，该进程只能在一个处理机上运行；
   * 多线程进程，可以将一个进程的多个线程分配到多个处理机上，加速进程的执行；



### 2.7.3 线程的状态和线程控制块

1. 线程运行的三个状态：
   * 执行：
   * 就绪：
   * 阻塞：
2. 线程控制块TCB：
   * 线程标识符
   * 一组寄存器
   * 线程运行状态
   * 优先级
   * 线程专有存储区
   * 信号屏蔽
   * 堆栈指针
3. 多线程OS中的进程属性
   * 进程是一个可拥有资源的基本单位；
   * 多个线程可并发执行；
   * 进程已不再是可执行的实体；(线程是可执行的实体)



## 2.8 线程的实现

### 2.8.1 线程的实现方式

1. 内核支持线程KST(Kernel Supported Threads)

   * 描述：线程的创建、阻塞、撤销、切换都是在内核空间中实现的，需要内核的支持；

   * 特点：以线程为单位进行调度；

   * 优缺点：

     * 并行性：在多处理机系统中，同一个进程中的多个线程可以并行执行；

     * 阻塞性：如果某进程中的一个线程被阻塞，内核可以调度该进程中的其他线程运行；

     * 模式切换开销：进行用户进程的切换时，需要从用户态转到核心态，模式切换开销较大；

       (因为用户进程的线程在用户态进行，而线程的调度和管理是在内核实现的)

2. 用户级线程ULT(User Level Threads)

   * 描述：线程的创建、阻塞、撤销、切换都是在用户空间中实现的，不需要内核的支持；
   * 特点：以进程为单位进行调度；
   * 优缺点：
     * 模式切换开销：线程切换不需要由用户空间转到内核空间，模式切换开销小；
     * 并行性：每个进程仅能分配到一个CPU，进程中仅有一个线程能执行，多线程不可并行执行；
     * 阻塞性：当一个线程被阻塞时，不仅该线程被阻塞，进程内的所有线程都会被阻塞；

3. 组合方式ULT/KST

   * 描述：内核支持多个内核支持线程的建立、调度和管理，也允许用户应用程序建立、调度和管理用户级线程；
   * 实现：用户级线程通过时分复用内核支持线程，使一个内核支持线程对应多个用户级线程；
   * 特点：结合了KST/ULT两者的优点，并克服了各自的不足；
   * 根据用户级进程和内核支持线程连接方式的不同，形成了三种不同的模型：
     * 多对一模型：将多个用户进程映射到一个内核控制线程；

       * 优点：

         * 开销小；
         * 效率高；

       * 缺点：

         * 并发性：如果一个线程在访问内核时发生阻塞，整个进程都会被阻塞；

         * 并行性：同一时刻，只有一个线程能访问内核，多个线程不能在多处理机上运行；

     * 一对一模型：将每一个用户线程都映射到一个内核支持线程；

       * 优点：
         * 并发性：当一个线程阻塞时，允许调度另一个线程运行；
         * 并行性：允许多个线程并行地运行在多处理机系统上；
       * 缺点：
         * 开销大(每创建一个用户线程就需要创建一个内核线程)

     * 多对多模型：将许多用户线程映射到同样数量或更少数量的内核线程上；

       * 结合了以上两种模型的优点；



### 2.8.2 线程的实现

1. 内核支持线程的实现：

   * 创建新进程时，为其分配一个任务数据区PTDA(Per Task Data Area)，其中包括若干个TCB空间；
   * 每当进程要创建一个线程时，为新线程分配TCB，写入信息，并为之分配资源；
   * 撤销一个线程时，回收该线程的所有资源和TCB；
   * 线程的调度与切换与进程的调度与切换类似，但开销要小很多；

2. 用户级线程的实现：

   用户级进程的实现，借助于中间系统，中间系统分类：

   * 运行时系统(Runtime System)
     * 实质：用于管理和控制线程的函数的集合；
     * 运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口；
   * 内核控制线程
     * 内核控制线程：又称轻型线程LWP(Light Weight Process)
     * 通过LWP可以把用户级线程与内核线程连接起来，相当于中间的桥梁；



### 2.8.3 线程的创建和终止

1. 线程的创建
2. 线程的终止

