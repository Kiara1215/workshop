[TOC]



# 散列表和哈希算法

* 哈希表：保持数组中的每个元素与其索引相互对应的最好方法；
    * Java：HashMap(支持在O(1)时间内查找、插入、删除元素)；
    * C++：Map(基于红黑树实现，能根据key在O(logn)时间复杂度内查找到对应的value)；



## 18. 散列表(上)

Q：word里输入一个错误的英文单词，它就会用标红的方式提示"拼写错误"，这个单词拼写检查功能是如何实现？

A：

* 分析：
    * 常用的英文单词大约20万个，假设每个单词平均长度为20，平均一个单词占用10字节空间，20万单词总共占用2MB内存，对于现在的计算机来说，可以完全放入内存；
* 方案：
    * 用散列表来存储整个英文单词词典；
    * 当用户输入某英文单词时，拿用户输入的英文单词去散列表中查找：
        * 若找到，说明拼写正确；
        * 若没找到，说明拼写错误；



Q：有10万条URL访问日志，如何按照访问次数给URL排序？

A：

* Solution1：
    * 用哈希表的链表法，以访问次数为slot，访问次数相同的URL放入同一个slot中，遍历完就排序完毕，时间复杂度为O(n)；
* Solution2：
    * 遍历10万条数据，以URL为key，访问次数为value，构建哈希表，时间复杂度为O(n)；
    * 根据访问次数进行排序(快速排序O(nlogn)，桶排序or计数排序 O(n))；



Q：有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？

A：

* 以其中一个字符串数组构建哈希表，key为字符串，value为出现次数；
* 遍历另一个字符串数组，以字符串为key在散列表中查找，若value大于0，说明存在相同字符串；
* 制作哈希表和遍历的时间复杂度都为O(n)，所以总的时间复杂度为O(n)；



1. 散列思想：

    * 举例：
        * 假如有89位选手参加运动会，编号为1-89，根据参赛选手的编号，来查找对应选手的信息；
        * 可以将这89位选手的信息存放在数组中：编号为1的选手的信息，放到数组下标为1的位置，……；
        * 编号与数组下标一一对应，当我们需要查询参赛编号为x的选手时，只需取出下标为x的数组元素；
        * 在此基础上，编号改为6位数，比如051167，其中，前两位05表示年级，中间两位11表示班级，后两位还是原来的编号1-89；
        * 此时，可以截取参赛编号的后两位作为数组下标，来实现根据编号在O(1)时间内快速查找对应元素；
    * 概念引入：
        * 键(key)：参赛选手的编号，用来标识一个选手；
        * 散列函数(hash function)：把编号转化为数组下标的映射方法；
        * 散列值(hash value)：由散列函数计算得到的值；
    * 散列表(Hash Table)：
        - 利用数组支持按照下标随机访问时，时间复杂度是O(1)的特点，通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查找元素时，用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据；

2. 散列函数：

    * 举例：

        * 在前面的例子中，散列函数写成伪代码如下：

            ```java
            int hash(String key)
            {
            	// 获取后两位字符
                string lastTwoChars = key.substr(length-2, length);
                
                // 将后两位字符转化为数字
                int hashValue = convert lastTwoChars to int-type;
                return hashValue;
            }
            ```

    * 散列函数设计的三点基本要求：

        * 散列函数计算得到的散列值是一个非负整数；
        
            (因为散列值是数组下标)
        
        * 如果key1 == key2，那么hash(key1) == hash(key2)；
        
            (同样的键值通过散列函数映射得到的散列值相同)
        
        * 如果key1 != key2，那么hash(key1) != hash(key2)；
        
            (几乎不可能做到，肯定会有散列冲突)

3. 散列冲突：

    * 引入：

        * 再好的散列函数也无法避免散列冲突；而且数组的存储空间有限，也会加大散列冲突的概率；

    * 解决方法：

        * 开放寻址法(Open addressing)：

            * 核心思想：

                * 如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入；

            * 探测方法：

                * 线性探测(Linear probing)：
                    * 插入：
                        * 当我们往散列表中插入一个数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了。我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止；
                    * 查找：
                        * 通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素没在散列表中；
                    * 删除：
                        * 不能单纯地把要删除的元素设置为空，可以将其特殊标记为deleted；
                        * 当线性查找时，遇到标记为deleted的空间，并不停下来，而是继续往下探测；
                * 二次探测(Quadratic probing)：
                    * 与线性探测类似，只是探测步长不同；
                    * 线性探测时，步长依次为：hash(key)+0, hash(key)+1, hash(key)+2, ……；
                    * 二次探测时，步长依次为：hash(key)+0, hash(key)+1^2, hash(key)+2^2, ……;
                * 双重散列(Double hashing)：
                    * 不仅要使用一个散列函数，而是使用一组散列函数：hash1(key), hash2(key), ……；
                    * 先用第一个散列函数，如果计算得到的存储位置已经被占用，在用第二个散列函数，以此类推，直到找到空闲的存储位置；

            * 装载因子(load factor)：

                * 引入：

                    * 不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率会提高；
                    * 为了保证散列表的操作效率，要尽可能保证散列表中有一定比例的空闲槽位；
                    * 用装载因子来表示空闲槽位的多少；

                * 计算公式：

                    ```C++
                    装载因子 = 填入表中的元素个数 / 散列表长度
                    /* 装载因子越大，说明空闲位置越少，冲突越多，性能下降 */
                    ```

        * 链表法(Chaining)：

            * 原理：
                * 在散列表中，每个"桶(bucket)"或"槽(slot)"会对应一条链表；
                * 所有散列值相同的元素，都放到相同槽位对应的链表中；
            * 时间复杂度：
                * 插入：O(1)
                    * 只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可；
                * 查找、删除：
                    * 同样通过散列函数计算出对应的散列槽位，然后遍历链表查找或删除；
                    * 时间复杂度与链表长度k成正比，O(k)；
                    * 对于散列比较均匀的散列函数，k = n/m；(n表示散列表中的数据个数，m表示槽位个数)





## 19. 散列表(中)

Q：如何设计一个工业级的散列表？来避免在散列冲突的情况下，散列表性能急剧下降。

A：

* 要求：
    * 支持快速查询、插入、删除操作；
    * 内存占用合理，不能浪费过多内存；
    * 性能稳定，极端情况下，性能也不会退化到无法接受的程度；
* 如何实现：
    * 设计一个合适的散列函数；
    * 定义装载因子阈值，并设计动态扩容策略；
    * 选择合适的散列冲突解决办法；



1. 如何设计散列函数？

    * 要求：

        * 散列函数不能太复杂；

            (复杂的散列函数耗费很多的计算时间，间接造成散列表性能下降)

        * 散列函数的生成值要尽可能随机并均匀分布；

            (避免或最小化散列冲突；即便出现散列冲突，每个槽里面的数据也相对比较平均)

    * 设计方法：

        * key是整数：
            * 取余法：Key mod TableSize(TableSize 最好为素数)；
            * 数据分析法：(参赛选手编号取后两位)；
        * key是字符串：
            * ASCII码值相加，再取余；
            * ASCII码值"进位"相加，再取余；

2. 装载因子过大怎么办？

    * 动态扩容：
        * 步骤：
            * 重新申请内存空间；
            * 重新计算哈希位置；(因为散列表大小改变，数据的存储位置也随之改变)
            * 搬移数据；
        * 时间复杂度分析：
            * 插入：
                * 最好：O(1)。不需要扩容；
                * 最坏：O(n)。重新分配内存，重新计算哈希位置，搬移数据；
                * 平均：O(1)。摊还分析；
            * 删除：O(1)；
        * 如何避免低效扩容？
            * 方法：
                * 为了解决一次性扩容耗时过多的情况，将扩容操作穿插在插入操作过程中；
            * 这期间的查询操作该如何做？
                * 先从新的散列表中查找，如果没找到，再去老的散列表中查找；

3. 如何选择冲突解决方法？

    * 开放寻址法：
        * 优点：
            * 不需要拉很多链表，节约内存；
            * 数据存储在数组中，可以有效利用CPU缓存加快查询速度；
            * 序列化简单；(链表法包含指针，序列化不容易)
        * 缺点：
            * 删除数据比较麻烦，需要特殊标记已经删除的数据；
            * 所有数据都存储在一个数组中，相比链表法，冲突代价更高；
            * 装载因子上限不能太大，内存利用率低；
        * 总结：
            * 当数据量较小，装载因子较小时，适合采用开放寻址法；(Java中ThreadLocalMap)
    * 链表法：
        * 优点：
            * 相比开放寻址法，内存利用率较高；(链表节点可以在需要的时候再创建)
            * 相比开放寻址法，对大装载因子的容忍度更高；
        * 缺点：
            * 需要存储指针，浪费内存；(特别是对小对象的存储)
            * 内存分配不连续，不能有效利用CPU缓存加快查找速度；
        * 改进：
            * 可以将链表改造成其他更高效的数据结构，比如跳表、红黑树，这样即使再出现散列冲突，极端情况下所有的数据都被散列到一个桶内，最终退化的查找时间也不过是O(logn)；
        * 总结：
            * 比较适合存储大对象、大数据量的散列表；
            * 相比开放寻址法，更加灵活，支持更多的优化策略，比如用红黑树代替链表；

4. 工业级散列表举例：(Java中HashMap)

    * 初始大小：

        * 默认初始大小为16；
        * 也可以修改默认初始大小，从而减少动态扩容次数，提高性能；

    * 装载因子和动态扩容：

        * 最大装载因子默认为0.75；
        * 当超过最大装载因子时，会启动自动扩容，每次扩容为原来的两倍大小；

    * 散列冲突解决办法：

        * 链表法；
        * 当链表过长(默认超过8)时，链表转化为红黑树；

    * 散列函数：(简单、高效、分布均匀)

        ```java
        int hash(Object key)
        {
            int h = key.hashCode();					// hashCode()返回Java的对象hash code
            return (h ^ (h >>> 16)) & (capacity-1); // capacity表示散列表大小
        }
        
        // A % B = A & (B - 1)
        
        // string类型的hashCode()：
        public int hashCode()
        {
            var1 = this.hash;
            if(var1 == 0 && this.value.length > 0)
            {
                char[] var2 = this.value;
                for(int var3 = 0; var3 < this.value.length; var3++)
                    var3 = 31 * var1 + var2[var3];
                this.hash = var1;
            }
            return var1;
        }
        ```



## 20. 散列表(下)

Q：为什么散列表和链表经常一起使用？

A：

* 散列表虽然支持高效地查找、插入、删除数据，但是散列表中的数据都是经过散列函数打乱之后无序存储的，也就是说，它无法支持按照某种顺序快速地遍历数据；
* 通过将散列表和链表结合起来，可以实现按照顺序遍历数据；



1. LRU缓存淘汰算法：
    * 按照访问时间排序的LinkedHashMap；
2. Redis有序集合：
    * 
3. Java LinkedHashMap：
    * 通过双向链表和散列表这两种数据结构组合实现；
    * "Linked"指双向链表，并非指链表法解决散列冲突；



## 21. 哈希算法(上)

Q：如何存储用户密码？

A：

* Solution:
    * 用哈希算法对用户密码加密后再存储；
    * 对于简单的用户密码，可以加盐(salt)，组合后再加密存储。以防止字典攻击；
* 字典攻击：
    * 维护一个常用密码的字典表，将字典中的每个密码用哈希算法计算哈希值；
    * 然后拿哈希值和脱库后的密文对比，若相同，基本可以认为加密之后的密码对应的明文就是字典中的这个密码；
* Note：
    * 安全和攻击是一种博弈关系，不存在绝对的安全，所有的安全措施都只是增加攻击的成本而已；



1. 什么是哈希算法？
    * 定义：
        * 将任意长度的二进制值串，映射为固定长度的二进制值串，这个映射的规则就是哈希算法；
        * 通过原始数据映射得到的二进制值串就是哈希值；
    * 要求：
        * 从哈希值不能反向推导出原始数据；(所以哈希算法也叫单向哈希算法)
        * 对输入数据非常敏感，哪怕原始数据只修改了一个bit，最后得到的哈希值也大不相同；
        * 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
        * 高效，针对较长的原始数据，也能快速计算出哈希值；
    * 举例：
        * MD5、SHA等
2. 应用：
    * 安全加密：
      * 种类：
        * MD5(Message-Digest Algorithm，消息摘要算法)
        * SHA(Secure Hash Algorithm，安全散列算法)
        * DES(Data Encryption Standard，数据加密标准)
        * AES(Advanced Encryption Standard，高级加密标准)
      * 两点要求格外重要：
        * 从哈希值不能反向推导出原始数据；(加密就是为了防止原始数据泄漏)
        * 散列冲突概率很小；(但散列冲突概率不可能为0)
      * 为什么哈希算法无法做到零冲突？
        * 鸽巢理论：如果有10个鸽巢，11只鸽子，肯定有一个鸽巢的鸽子数量多于1；
        * 由哈希算法产生的哈希值的长度是固定且有限的，只能表示有限的数据，而我们要哈希的数据是无穷的；
        * 一般情况下，哈希值越长的哈希算法，散列冲突概率越低，但效率越低；
    * 唯一标识：
    
        * 问题：
            * 要在海量的图库中，搜索一张图片是否存在；
        * 分析：
            * 任何文件都是以二进制码串存放在计算机中的，可以拿要查找图片的二进制码串与图库中所有图片的二进制码串进行一一对比，但效率低下；
        * 解决方法：
            * 对图库中的所有图片，从该图片的二进制码串中取开头100字节，中间100字节，最后100字节。将这300个字节放一起，通过哈希算法，得到一个哈希字符串，作为该图片的唯一标识；
            * 将每个图片的唯一标识和存储位置信息，都存储在散列表中；
            * 当需要判断一个图片在不在图库中时，先通过相同的哈希算法计算得到其哈希值，然后在散列表中查找，是否存在这样一个唯一标识；
            * 若存在，通过存储位置信息取出该图片，与当前图片做全量对比，看是否完全一样。若一样，说明存在；若不一样，说明尽管它们的唯一标识相同，但并不是相同的图片；
    * 数据校验：
    
        * BT下载软件：BT下载原理是基于P2P协议的：文件被分割成很多块，存放在多个机器上；从多个机器上并行下载同一个文件的各个部分；下载完成后将各部分拼接成一个完整的文件；
        * 如何校验下载文件块的安全、正确、完整？
        * 对各文件块分别计算哈希值，并且保存在种子文件中；
        * 当文件分块下载完成后，通过相同的哈希算法，对下载好的各分块文件求哈希值；
        * 将其与种子文件中的哈希值相比较；
        * 若相同，则下载的文件块完整正确，可以放在一起拼接；若不同，则不正确，需要重新下载该文件块
    * 散列函数：
    
        * 要求：
            * 不太关心散列冲突，即使有少量散列冲突，可以通过开放定址法或链表法解决；
            * 不关心是否能反向解密；
            * 更关心哈希值分布是否均匀，计算效率是否高；
        * 特点：
            * 散列函数用的散列算法一般都比较简单，追求效率；



## 22. 哈希算法(下)

Q：哈希算法在分布式系统中有哪些应用？

A：负载均衡、数据分片、分布式存储；



Q：哈希算法的其他应用？

A：网络协议中的CRC校验、Git commit id；



1. 负载均衡：
    * 负载均衡算法：
        * 轮询；
        * 随机；
        * 加权轮询；
    * 如何实现一个会话粘滞(session sticky)的负载均衡算法？
        * 含义解读：需要在同一个客户端上，在一次会话中的所有请求都路由到同一个路由器上；
        * 方法：
2. 数据分片：
    * 如何统计"搜索关键词"出现的次数？
        * 问题描述：
        * 解决方案：(计算哈希值，跟n取模，保证相同的关键词被分配到同一台机器上)
    * 如何快速判断图片是否在图库中？
        * 问题描述：
        * 解决方案：
3. 分布式存储：
    * 问题：
        * 扩容后要rehash；
    * 一致性哈希算法：
        * 作用：可以解决扩容时rehash问题；