# 跳表



## 17. 跳表

Q：为什么Redis会选用跳表来实现有序集合？

A：实现简单；按区间查找数据的效率更高(比如查找区间[100,200)的数据)；



1. 引入：

    * 二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现；
    * 如果数据存储在链表中，就真的没办法用二分查找了吗？
    * 将链表稍微改造一下，就可以支持类似"二分查找"的算法，将改造后的链表称为"跳表"(skip list)；
    * 跳表是一种各方面性能都比较优秀的动态数据结构，支持快速的插入、删除、查找操作；(类似红黑树)

2. 如何理解跳表？

    * 链表的局限性：
        * 即使链表中的数据是有序的，如果想要查找某个数据，也只能从头到尾遍历链表，时间复杂度O(n)；
    * 如何提高链表的查找效率？
        * 给链表加上多级索引(就叫跳表)；
        * 查询数据的时候，先从最上层索引开始，逐层往下；
        * 可以有效减少需要遍历的节点的数目，从而提高查找效率；

3. 跳表查询到底有多快？

    * 引入：
        * 在单链表中，查询某个数据的时间复杂度是O(n)；
        * 在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？
    * 分析：
        * 如果链表有n个节点，会有多少级索引？
        * 每两个节点抽出一个节点作为上一级索引的节点，那么第一级索引的节点数为n/2，第二级为n/4，……，第k级索引节点的个数为n/(2^k)；
        * 设索引有h级，最高级索引有两个节点，所以n/(2^h) = 2, $n = log_2n - 1$。
        * 如果包含原始链表这一层，整个跳表的高度就是$ log_2n $；
        * 在跳表中查询某个数据的时候，每一层都需要遍历m个节点，所以总的时间复杂度为O(m*logn)
        * m = 3， 所以总的时间复杂度为O(logn)，与二分查找的时间复杂度相同；
    * 总结：
        * 查找效率的提升，前提是建立了多级索引；(以空间换时间)

4. 跳表是不是很浪费内存？

    * 引入：
        * 比起链表，跳表需要存储多级索引，肯定要消耗更多的存储空间，那么到底需要多少额外的空间呢？
    * 分析：
        * 假设原始链表大小为n，每两个节点抽出一个索引；
        * 第一层索引节点数n/2，第二层n/4，……，最后一层2；
        * 等比数列求和：n/2 + n/4 + … + 2 = n - 2；
        * 所以跳表的空间复杂度是O(n)；
    * 降低索引占用的内存空间的方法：
        * 每三个或五个节点，抽出一个节点作为上级索引；
        * 每三个节点抽出一个索引节点时，总的节点个数为：n/3 + n/9 + … + 1 = n/2；
        * 空间复杂度为O(n)，但减少了一半索引节点的存储空间；
    * Note：
        * 实际开发中，不必太在意索引占用的额外空间。因为在实际开发中，原始链表可能存储的是很大的对象，而索引节点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引节点大很多时，索引节点占用的额外空间就可以忽略；

5. 高效的动态插入和删除：

    * 插入：O(logn)
        * 和查找过程类似；
    * 删除：O(logn)
        * 如果节点在索引中也有出现，除了要删除原始链表中的节点，还要删除索引中的；
        * 单链表中的删除操作要获取前驱节点，双链表不用；

6. 跳表索引动态更新：

    * 引入：
        * 作为一种动态数据结构，需要维护索引与原始链表大小之间的平衡；
        * 如果链表中节点多了，索引节点就相应增加一些，避免复杂度退化；
        * 红黑树、AVL树这样的平衡二叉树中，通过左右旋的方式保持左右子树的平衡；
        * 跳表中通过随机函数来维护平衡；
    * 随机函数：
        * 当我们向原始链表中插入数据时，可以同时将这个数据插入到部分索引层中；
        * 通过一个随机函数来决定将这个节点插入到哪几级索引；
        * 比如随机函数生成了K，就将这个节点添加到第1级到第K级这K级索引中；
        * 随机函数的选择很讲究，要能保证跳表索引大小和数据大小的平衡性，不至于性能过度退化；

7. 实现：

    ```
    
    ```

8. 跳表与红黑树：

    * 查找、插入、删除：跳表与红黑树效率相同；
    * 按照区间查找数据：跳表效率更高；
    * 跳表的实现更为简单；

