[TOC]

# 第十章 泛型程序设计与C++标准模板库

* C++语言提供的标准模板库STL(Standard Template Library)，便是面向对象程序设计与泛型程序设计(Generic Programming)思想结合的一个良好典范。



## 10.1 泛型程序设计及STL的结构

### 10.1.1 泛型程序设计的基本概念

1. 定义：

   * 泛型程序设计，就是编写不依赖于具体数据结构的程序；

     (C++中，模板是泛型程序设计的主要工具)

2. 主要思想：

   * 将算法从特定的数据结构中抽象出来，使算法成为通用的，可以作用于各种不同的数据结构；

     (将以函数模板形式实现的通用算法与各种容器结合，提高了软件的复用性)

3. 概念(concept)：

   * 定义：用来描述泛型程序设计中作为参数的数据类型所需具备的功能；
   * 内涵：这些功能；
   * 外延：具备这些功能的所有数据类型；
   * 举例："可以比较大小、具有公有的复制构造函数并可以用"="赋值的所有数据类型"就是一个概念Sortable
   * 概念之间有包含关系；(Comparable, Assignable, Sortable)

4. 模型(model)：

   * 定义：具备一个概念所需要功能的数据类型称为这一概念的一个模型；
   * 举例：int数据类型就是Sortable概念的一个模型；



### 10.1.2 STL简介

1. STL提供了一些常用的数据结构和算法；(vector, list；排序、查找等算法)

2. STL更大的意义：STL定义了一套概念体系，为泛型程序设计提供了逻辑基础；

3. 程序实例：一个最简单的STL程序

   (从标准输入读入几个整数，存入向量容器，用STL输出它们的相反数)

   ```C++
   #include <iostream>
   #include <vector>
   #include <iterator>
   #include <algorithm>
   #include <functional>
   using namespace std;
   
   int main()
   {
       const N = 5;
       vector<int> s(N);
       
       for(int i = 0; i < N; i++)
           cin >> s[i];
       
       transform(s.begin(), s.end(), ostream_iterator<int>(cout, " "), negate<int>());
       cout << endl;
       
       return 0;
   }
   ```

4. Note：

   * 容器：vector\<int>；

   * 迭代器：s.begin()、s.end()、ostream_iterator\<int>(cout, " ")；
   
   * 函数对象：negate\<int>()；
   
    * negate是一个类模板，重载了"()"运算符，接收一个参数，该运算符的返回值就是该参数的相反数；
   
    * 算法：transform()；
   
       ```C++
       /* 举例：transform()算法的一种实现 */
       template<class InputIterator, class OutputIterator, class UnaryFunction>
       OutputIterator transform(InputIterator first, InputIterator last,
                                OutputIterator result, UnaryFunction op)
       {
       	for(; first != last; ++first, ++result)
       		*result = op(*first);
       	return result;
       }
       // 顺序遍历first和last两个迭代器所指向的元素，将每个元素的值作为函数对象op的参数，将op的返回值通过输出迭代器result输出。遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置。
       ```
   
5. STL的四种基本组件：

   * 容器(container)：

     * 作用：容纳、包含一组元素的对象；

     * 两种基本类型：

       * 顺序容器(sequence container)：

         * 含义：将一组具有相同类型的元素以严格的线性形式组织起来；
         * 类型：向量(vector)、双端队列(deque)、链表(list)；
       * 关联容器(associative container)：
         * 含义：具有根据一组索引来快速提取元素的能力；
         * 类型：集合(set)、多重集合(multiset)、映射(map)、多重映射(multimap)；
     * 容器适配器(adapter)：
         * 类型：stack, queue, priority_queue;
     
  * NOTE : 使用不同的容器，要包含不同的头文件(vector, deque, set, map)；
    
* 迭代器(iterator)：
  
  * 作用：提供顺序访问容器中每个元素的方法；
     * 性质：
       * 可以使用"++"运算符来获得指向下一个元素的迭代器；
       * 可以使用"*"运算符来访问一个迭代器所指向的元素；
       * 如果元素类型是类或结构体，可使用"->"直接访问该元素的一个成员；
     * Note ：
       * 指针本身就是一种迭代器，迭代器是泛化的指针；
       
           (指针指向内存中的某个位置，迭代器指向容器中的元素)
       
       * 使用独立于STL容器的迭代器，需要包含头文件\<iterator>；
  
* 函数对象(function object)：
  
  * 作用：函数对象是一个行为类似函数的对象，可以像函数一样调用；
     * Note : 
       * 函数对象是泛化的函数；
       
           (任何普通函数和重载了"()"运算符的类的对象都可以作为函数对象使用)
       
       * 使用STL的函数对象，需要包含头文件\<functional>；
  
* 算法(algorithm)：
  
  * 作用：STL包含了70多个算法，覆盖了相当大的领域；
  
  * 特点：统一性，可广泛用于不同对象和内置的数据类型；
     * Note：使用STL的算法，需要包含头文件\<algorithm>；
  
6. STL的4类基本组件的关系：参考书(P.402 图10-1)

   * STL把迭代器作为算法的参数，通过迭代器来访问容器而不是把容器直接作为算法的参数；
   * STL把函数对象作为算法的参数，而不是把函数所执行的运算作为算法的一部分；



## 10.2 迭代器

1. 迭代器是算法和容器的中间人：
   * 算法适用于多种容器，而每种容器中存放的元素又可以是多种类型，此时要使用迭代器来作为中介；
   * STL的每一个容器类模板中，都定义了一组对应的迭代器类；



### 10.2.1 输入流迭代器和输出流迭代器

1. 输入流迭代器

   * 作用：用来从一个输入流中连续地输入某种类型的数据；

   * 类模板：

     ```C++
     template<class T> istream_iterator<T>;
     ```
     
   * 构造函数：
   
     ```C++
     istream_iterator(istream& in);		// 参数in表示用来输入数据的输入流(例如cin)
     istream_iterator();					// 默认构造函数，用来指示输入流的结束
     ```
   
   * 支持"*"、"++"、"->"等运算符：

     * 用"*"可访问刚刚读取的数据；
  * 用"++"可从输入流中读取下一个元素；
     * 若类型T为类类型或结构类型，用"->"可以直接访问刚刚读取元素的成员；
   
   * 如何判断一个输入流是否结束：
   
  * istream_iterator有一个默认构造函数，用该函数构造出的迭代器指向的就是输入流的结束位置；

2. 输出流迭代器

   * 作用：用来向一个输出流中连续地输出某种类型的数据；

   * 类模板：

     ```C++
     template<class T> ostream_iterator<T>;
     ```

   * 构造函数：

     ```C++
     ostream_iterator(ostream& out);
     ostream_iterator(ostream& out, const char* delimiter);
     
     // 参数out表示将数据输出到的输出流；
     // 参数delimiter是可选的，表示两输出数据之间的分隔符；
     ```

   * 支持"*"、"++"等运算符：

     * 对于一个输出迭代器iter，*iter只能作为赋值运算符的左值；

       (*iter = x, 相当于执行了 out << x 或 out << x << delimiter)

     * "++"运算符并不会使该迭代器的状态发生任何改变，只是作为一个统一的接口；

3. 程序实例：从标准输入读入几个实数，分别将它们的平方输出

   ```C++
   #include <iostream>
   #include <iterator>
   #include <algorithm>
   using namespace std;
   
   double square(double x)
   {
       return x*x;
   }
   
   int main()
   {
       transform(istream_iterator<double>(cin), istream_iterator<double>(),
                ostream_iterator<double>(cout, "\t"), square);
       cout << endl;
       return 0;
   }
   ```

4. 意义：

   * 虽然输入流迭代器和输出流迭代器本身并不能比输入流和输出流提供更强大的功能，但由于它们采用迭代器的接口，在这两种迭代器的帮助下，输入流和输出流可以直接参与STL的算法；

   * 输入流迭代器和输出流迭代器可以被看作是一种适配器(adapter)；

       (适配器是指用于为已有对象提供新的接口的对象，适配器本身一般不提供新的功能)



### 10.2.2 迭代器的分类

* 所有迭代器都具备的功能：
    * ++p1：使迭代器指向下一个元素，且该表达式的返回值为p1自身的引用；
    * p1++：使迭代器指向下一个元素，该表达式的返回值是不确定的；



1. 输入迭代器(Input Iterator)：
   * 作用：可用来从序列中读取数据，但不一定能够向其写入数据；
   * 特点：支持对序列进行不可重复的单向遍历；
   * Note：
     * 如果p1 == p2，并不能保证++p1 == ++p2，更不能保证*(++p1) == *(++p2)；
     * 由输入迭代器读入的序列不能保证是可重复的；
     * 输入迭代器只适用于作为那些只需遍历一次的算法的输入；
2. 输出迭代器(Output Iterator)：
   * 作用：可用来向序列中写入数据，但不一定能够从中读取数据；
   * 特点：支持对序列进行不可重复的单向遍历；
   * Note：
     * 使用输出迭代器，写入元素的操作和使用"++"自增的操作必须交替进行；
3. 前向迭代器(Forward Iterator)：
   * 作用：是输入迭代器和输出迭代器这两个概念的子概念，既支持数据读取，也支持数据写入；
   * 特点：支持对序列进行可重复的单向遍历；
   * Note：
     * 如果p1 == p1，那么++p1 == ++p2一定成立；
4. 双向迭代器(Bidirectional Iterator)：
   * 作用：是前向迭代器的子概念，支持迭代器反向移动；
5. 随机访问迭代器(Random Accesss Iterator)
   * 作用：是双向迭代器的子概念，支持将迭代器向前或向后移动n个元素；(指针)



### 10.2.3 迭代器的区间

1. 作用：STL算法的形参常常包括一对输入迭代器，用它们所构成的区间来表示输入数据的序列；

2. 有效区间：[p1, p2)

3. 程序实例：综合运用几种迭代器的示例

   ```C++
   #include <algorithm>
   #include <iterator>
   #include <vector>
   #include <iostream>
   using namespace std;
   
   template<class T, class InputIterator, class OutputIterator>
   void mySort(InputIterator first, InputIterator last, OutputIterator result)
   {
       vector<T> s;
       for(; first != last; ++first)
           s.push_back(*fisrt);
       sort(s.begin(), s.end());			// 对s进行排序，sort函数的参数必须是随机访问迭代器
       copy(s.begin(), s.end(), result);	// 将s序列通过输出迭代器result输出
   }
   
   int main()
   {
       double a[5] = {1.2, 2.4, 0.8, 3.3, 3.2};
       mySort<double>(a, a+5, ostream_iterator<double>(cout, " "));
       cout << endl;
       
       mySort<int>(istream_iterator<int>(cin),istream_iterator<int>(),
                  ostream_iterator<int>(cout, " "));
       cout << endl;
       
       return 0;
   }
   ```
   
   * Note：

     * sort算法：

       ```C++
    template<class RandomAccessIterator>
       void sort(RandomAccessIterator first, RandomAccessIterator last);
       // 将[first, last)区间内的数据从小到大排序，排序结果就放在原位，只接收随机访问存储器作为参数
       ```
   
     * copy算法：

       ```C++
    template<class InputIterator, class OutputIterator>
       OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);
       // 将[first, last)区间内的数据序列通过输出迭代器result输出
       ```
   
     * 在设计一个算法时，如果用迭代器作为参数，应当尽可能用内涵尽可能小、外延尽可能大的迭代器概念，这样适用范围最广；



### 10.2.4 迭代器的辅助函数

* STL为迭代器提供了两个辅助函数模板：advance和distance；
* 它们为所有迭代器提供了一些原本只有随机访问迭代器才具有的访问能力：
    * 前进或后退多少元素；
    * 计算两个迭代器之间的距离；



1. advance：

   * 作用：前进或后退多少多少元素；

   * 函数模板：

     ```C++
     template<class InputIterator, class Distance>
     void advance(InputIterator& iter, Distance n);
     // 对于双向迭代器或随机访问迭代器，n可取负值，表示后退
     
     advance(iter, n);
     ```
   
2. distance：

   * 作用：计算两个迭代器之间的距离；

   * 函数模板：

     ```C++
     template<class InputIterator>
     unsigned distance(InputIterator first, InputIterator last);
     // 用来计算first经多少次"++"运算后可到达last, [first, last)必须是一个有效区间
     
     distance(first, last); 	/*= last - first*/
     ```



## 10.3 容器

### 10.3.1 容器的基本功能与分类

1. 基本功能：(设S表示一种容器类型(如vector\<int>)，s1, s2都是S类型的实例)

   ```C++
   S s1;				// 默认构造函数，用于构造一个没有任何元素的空容器
   s1 op s2;			// op可以是==,!=,<,<=,>,>=之一，会对两个容器之间的元素按照字典顺序进行比较
   s1.begin();			// 返回指向s1第一个元素的迭代器
   s1.end();			// 返回指向s1最后一个元素的下一个位置的迭代器
   s1.clear();			// 将容器s1的内容清空
   s1.empty();			// 返回一个bool值，表示s1容器是否为空
   s1.size();			// 返回s1的元素个数
   s1.swap(s2);		// 将s1容器和s2容器的内容交换
   ```

   * Note：上面的操作中，有些操作之间彼此可以转换，但未必具有相同的效率：
       * s1.empty() 可以转换为 s1.size() == 0，但前者更高效；
       * s1.swap(s2) 可以转换为 {S tmp(s1); s1 = s2; s2 = tmp;}，但前者更高效；

2. 迭代器的类型名表示方式：(S为容器类型，T为容器中的元素类型)

   ```C++
	S::iterator				// 表示与S相关的普通迭代器类型，迭代器指向元素为T
   S::const_iterator		// 表示与S相关的常迭代器类型，迭代器指向元素的类型为const T。
       					// 因此只能通过迭代器读取元素，不能通过迭代器改写元素
       
   // 当s1是常量时，使用s1.begin(), s1.end()返回的迭代器的类型就是S::const_iterator, 否则是S::iterator
   ```
   
3. 基于组织方式的分类：

   * 顺序容器(Sequence Container)
   * 关联容器(Associative Container)

4. 按照与元素所关联的迭代器划分：

   * 可逆容器(Reversible Container)
   * 随机访问容器(Random Access Container)

5. 逆向迭代器：

   * 目的：

     * 对一个可逆容器进行逆序遍历时，可以通过对其迭代器使用"--"运算来进行，但STL算法的输入都是用正向区间来表示的，所以这样做不方便；

   * 成员函数：

     ```C++
     s1.rbegin();			// 得到指向容器最后一个元素的逆向迭代器
     s1.rend();				// 得到指向容器第一个元素前一个位置的迭代器
     ```

   * 逆向迭代器的类型名表示方式：

     ```C++
     S::reverse_iterator
     S::const_reverse_iterator
     ```

   * 实质：

     * 是普通迭代器的适配器，逆向迭代器的"++"被映射为普通迭代器的"--"，"--"被映射为"++"；

     * 举例：将一个整形向量容器s1的内容逆向输出到标准输出

       ```C++
       copy(s1.rbegin(), s1.rend(), ostream_iterator(cout, " "));
       ```

   * Note：

     * 一个迭代器和它的逆向迭代器可以相互转换；

       ```C++
       若p1是S::iterator类型的迭代器，则使用表达式S::reverse_iterator(p1)可以得到与p1对应的逆向迭代器；
       
       逆向迭代器提供一个成员函数base，用它可以得到用于构造该逆向迭代器的那一个迭代器：
       若r1是通过r1 = S::iterator(p1)构造的逆向迭代器，
       那么r1.base() == p1
       注意：r1和p1并不指向同一个元素，r1所指向的元素总是与p1-1所指向的元素相同
       
       // 相等关系
       s1.rbegin() = S::reverse_iterator(s1.end());
       s1.rbegin().base() = s1.end();
       
       s1.rend() = S::reverse_iterator(s1.begin());
       s1.rend().base() = s1.begin();
       ```



### 10.3.2 顺序容器

1. 特点：

    * 包括向量(vector)、双端队列(deque)、列表(list)；
    * 在逻辑上可看成是一个长度可扩展的数组，容器中的元素都线性排列；
    * 程序员可以随时决定每个元素在容器中的位置，可以随时向指定位置插入新的元素和删除已有元素；
    * 每种类型的容器都是一个模板，都具有一个模板参数，表示容器的元素类型，该类型必须是Assignable；

2. 基本功能：

    (S表示容器类型名，s表示S类型的一个实例，T表示S容器的元素类型，t表示T类型的一个实例，n表示一个整形数据，p1, p2表示s中元素的迭代器，q1, q2表示任何指向T类型元素的输入迭代器)

    * 构造函数：

        ```C++
        S s(n, t);
        S s(n);
        S s(q1, q2);
        ```

    * 赋值函数：

        ```C++
        s.assign(n, t);
        s.assign(n);
        s.assign(q1, q2);
        ```

    * 元素的插入：

        ```C++
        s.insert(p1, t);			// 返回一个迭代器指向新插入的元素
        s.insert(p1, n, t);
        s.insert(p1, q1, q2);
        ```

    * 元素的删除：

        ```C++
        s.erase(p1);				// 返回被删除元素的下一个元素的迭代器
        s.erase(p1, p2);			// 返回删除前p2所指向元素的迭代器
        ```

    * 改变容器的大小：

        ```C++
        s.resize(n);
        ```

    * 首尾元素的直接访问：

        ```C++
        s.front();					// 获得首元素的引用
        s.back();					// 获得尾元素的引用
        ```

    * 在容器的尾部插入、删除元素：

        ```C++
        s.push_back(t);				// 向尾部插入元素t
        s.pop_back();				// 将尾部元素删除
        ```

    * 在容器的头部插入、删除元素：

        ```C++
        // 前插顺序容器才支持的操作, deque, list支持, vector不支持
        s.push_front(t);			// 向容器头部插入元素t
        s.pop_front();				// 删除容器头部元素t
        
        // vector要想实现，需要调用insert, erase函数
        s.insert(s.begin(), t);
        s.erase(s.begin());
        ```

    * Note：前插顺序容器：

        * 列表和双端队列容器支持高效地在容器头部插入或删除元素，但是向量容器不支持；
        * 支持这一操作的概念构成了"前插顺序容器"(FrontInsertionSequeue)，是"顺序容器"的子概念；

3. 程序实例：顺序容器的基本操作

    ```C++
    #include <iostream>
    #include <list>
    #include <deque>
    using namespace std;
    
    template<class T>
    void printContainer(const char* msg, const T& s)
    {
        cout << msg << ": ";
        copy(s.begin(), s.end(), ostream_iterator<T>(cout, " "));
        cout << endl;
    }
    
    int main()
    {
        deque<int> s;
        for(int i = 0; i < 10; i++)
        {
            int x;
            cin >> x;
            s.push_front(x);
        }
        printContainer("deque at first", s);
        
        list<int> l(s.rbegin(), s.rend());
        printContainer("list at first", l);
        
        list<int>::iterator iter = l.begin();
        while(iter != l.end())
        {
            int v = *iter;
            iter = l.erase(iter);
            l.insert(++iter, v);
        }
        printContainer("list at last", l);
        
        s.assign(l.begin(), l.end());
        printContainer("deque at last", s);
        
        return 0;
    }
    ```

4. 三种顺序容器的特性：

    * 向量(vector)：

        * 特点：

            * 高效随机访问；
            * 高效向尾部加入新元素；

        * 实现：动态数组；

        * 动态扩展：

            * 当数组空间不够用时，向量容器对象会自动用new分配一块更大的空间(一般是当前大小的2倍)，使用赋值运算符"="将原有的数据分别复制到新的空间中，并将原有的空间释放；

        * 容量(capacity)和大小(size)：

            * 容量：所能容纳的元素个数；
            * 大小：实际容纳的元素个数；

            ```C++
            s.size();				// 返回s的当前大小
            s.capacity();			// 返回s的容量
            s.reserve(n);			// 若当前的容量>=n，什么也不做；否则扩大s的容量，使之不小于n
            ```

        * 插入(删除)元素：

            * 向量容器中插入新元素时，插入位置之后的元素都要顺序向后移动，整体效率不高；

            * 插入位置越靠前，执行插入所需要的时间就越多，但向尾部插入元素的效率还是比较高的；

            * 如果插入操作引起向量容器容量的扩展，那么在插入之前所获得的一切迭代器和指向向量元素的指针、引用都会失效；(因为内存空间被重新分配，元素的内存地址发生了改变)

            * 如果插入操作未引起向量容器容量的扩展，那么只有处于插入位置之后的迭代器和指针、引用会失效；

            * 删除元素与插入元素相似，被删除元素后面的元素都会向前移动，将被删除元素留下的空位补上

            * 被删除元素越靠前，删除操作所需要的时间就越多；

            * 删除操作不会引起向量容器容量的改变，因此被删除元素之前的所有元素的迭代器、指针、引用都不会失效，而被删除元素之后的所有元素的迭代器、指针、引用都会失效；

            * 程序实例：失效

                ```C++
                #include <iostream>
                #include <vector>
                #include <iterator>
                using namespace std;
                
                int main()
                {
                    vector<int> s;
                	s.reserve(3);
                	s.push_back(1);
                	s.push_back(2);
                
                	vector<int>::iterator iter1 = s.begin();
                	int* p1 = &s[0];
                	vector<int>::iterator iter2 = s.begin()+1;
                	int* p2 = &s[1];
                
                	s.insert(s.begin()+1, 3);	
                	cout << *iter1 << " " << *p1 << endl;		// 正确，可以得到结果"1 1"
                	cout << *iter2 << " " << *p2 << endl;		// 错误，"iter2"和"p2"失效
                    
                    return 0;
                }
                ```

        * Note：删除向量容器的元素时，并不会使空闲的空间被释放，可用下面的语句来释放多余空间：

            ```C++
        vector<T>(s.begin(), s.end()).swap(s);
            // 首先用S的内容创建一个临时的向量容器对象，再将该容器和s交换，这时s原先占有的空间已经属于临时对象，这条语句执行完后临时对象会被析构，空间被释放	
            ```

    * 双端队列(deque)：

        * 特点：

            * 支持向两端高效地插入数据；
            * 支持随机访问，但效率相比于vector要低很多；

        * 实现：分段数组(存放数据) + 索引数组(存放分段数组首地址)；

        * 向两端插入元素：

            * 效率高；(不需要对已有元素进行移动)

            * 所有的迭代器失效；(索引数组可能被重新分配，而迭代器依赖索引数组)

                (向两端插入新元素可能会引起索引数组中已有元素位置的改变)

            * 所有的指针和引用不会失效；(分段数组不变，而指针和引用依赖分段数组)

                (向两端加入新元素不会改变已有元素在分段数组中的位置)

        * 从两端删除数据：

            * 只会使被删除元素的指针、引用、迭代器失效，不会影响其他元素的指针、引用、迭代器；

        * 向中间插入(删除)元素：

            * 效率低；(需要移动大量数据)
            * 所有的迭代器失效；
            * 所有的指针和引用失效；

        * 程序实例：奇偶排序

            ```C++
            #include <iostream>
            #include <vector>
            #include <deque>
            #include <algorithm>
            #include <iterator>
            using namespace std;
            
            int main()
            {
                istream_iterator<int> i1(cin), i2;
                vector<int> s1(i1, i2);
                sort(s1.begin(), s1.end());
                
                deque<int> s2;
                for(vector<int>::iterator iter = s1.begin(); iter != s1.end(); ++iter)
                {
                    if(*iter % 2 == 0)
                        s2.push_back(*iter);
                    else
                        s2.push_front(*iter);
                }
                
                copy(s2.begin(), s2.end(), ostream_iterator<int>(cout, " "));
                cout << endl;
                
                return 0;
            }
            
            // istream_iterator有一个默认构造函数，用该函数构造出的迭代器指向的就是输入流的结束位置
            ```

        * Note：(该算法综合利用了向量容器和双端队列容器的优势)

            * 对向量容器的随机访问效率特别高，而sort算法需要大量的随机访问操作，因此排序时适宜用；
            * 而将奇偶数分开，需要向容器两端插入元素，双端队列能提供最高的效率；

    * 列表(list)：

        * 特点：

            * 不能随机访问；
            * 可以高效地在任意位置插入和删除元素；

        * 实现：双向链表；

        * 插入元素：不会使任何已有元素的指针、引用、迭代器失效；

        * 删除元素：只会使被删除元素的指针、引用、迭代器失效，而不会使已有元素的指针、引用、迭代器失效；

        * 接合(splice)：将一个列表中的一部分连续的元素从该链表中删除后，插入到另一个列表中；

            ```C++
            s1.splice(p, s2);
            s1.splice(p, s2, q1);
            s1.splice(p, s2, q1, q2);
            
            // 原先指向被接入s1中的那些元素的迭代器、指针、引用会失效，其他迭代器、指针、引用不受影响；
            ```

        * 程序实例：列表容器的splice操作

            ```C++
            #include <list>
            #include <iterator>
            #include <string>
            #include <iostream>
            using namespace std;
            
            int main()
            {
                string names1[] = {"Alice", "Helen", "Lucy", "Susan"};
                string names2[] = {"Bob", "David", "Levin", "Mike"};
                list<string> s1(names1, names1+4);
                list<string> s2(names2, names2+4);
                
                s2.splice(s2.end(), s1, s1.begin());
                list<string>::iterator iter1 = s1.begin();
                advance(iter1, 2);
                list<string>::iterator iter2 = s2.begin();
                ++iter2;
                list<string>::iterator iter3 = iter2;
                advance(iter3, 2);
                s1.splice(iter1, s2, iter2, iter3);
                
                copy(s1.begin(), s1.end(), ostream_iterator<string>(cout, " "));
                cout << endl;
                copy(s2.begin(), s2.end(), ostream_iterator<string>(cout, " "));
                cout << endl;
                
                return 0;
            }
            ```

    * 三种顺序容器的比较：

        (参考书P.422 表10-2)

5. 顺序容器的插入迭代器：

    * 目的：在顺序容器中插入元素，除了使用insert、push_front、push_back之外，还可使用插入迭代器；

    * 作用：插入迭代器是一种适配器，使用它可以通过输出迭代器的接口来向指定元素的指定位置插入元素；

    * 三种输出迭代器：

        * front_insert_iterator只适用于前插顺序容器(双端队列和列表)；
        * back_insert_iterator和insert_iterator适用于所有顺序容器；

        ```C++
        // 三种输出迭代器各是一种类类型
        template<class FrontInsertionSequence>
        class front_insert_iterator
        {
            ...;
        };
        
        template<class Sequence>
        class back_insert_iterator
        {
            ...;
        };
        
        template<class Sequence>
        class insert_iterator
        {
            ...;
        };
        ```

    * 用于构造插入迭代器的三个辅助函数：

        ```C++
// 插入迭代器可以通过构造函数来创建，但一般无需调用构造函数，可以直接调用辅助函数
        // 使用辅助函数与直接使用构造函数的优点在于：
        // 辅助函数是一般的函数模板，调用时可以自动推导出类型参数而无需显示给出，从而使代码变得简短；
        
        template<class FrontInsertionSequence>
        front_insert_iterator<FrontIntertionSequence> front_inserter(FrontInsertionSequence& s);
        
        template<class Sequence>
        back_insert_iterator<Sequence> back_inserter(Sequence& s);
        
        template<class Sequence, class Iterator>
        insert_iterator<Sequence, Iterator> inserter(Sequence& s, Iterator i); 
        
        // 参数s表示插入元素的容器，参数i表示插入元素的位置
        ```

    * 举例：将从标准输入得到的整数插入容器s的末尾

        ```C++
        copy(isteram_iterator<int>(cin), istream_iterator<int>(), back_inserter(s));
        ```

6. 顺序容器的适配器：

    * 作用：按照指定的顺序来访问和删除容器中的元素；(比如，栈和队列)

    * STL提供的容器适配器：栈(stack)、队列(queue)、优先队列(priority_queue)：

        ```C++
        // 栈可以用任何一种顺序容器作为基础容器，默认为deque
        template<class T, class Sequence = deque<T>>
        class stack
        {
            ...;
        };
        
        // 队列只允许用前插顺序容器作为基础容器(deque or list)，默认为deque
        template<class T, class FrontInsertionSequence = deque<T>>
        class queue
        {
            ...;
        };
        
        // 优先队列的基础容器必须是支持随机访问的顺序容器(vector or deque)，默认为vector
        // 元素弹出的顺序与压入顺序无关，每次总是弹出最"大"的一个元素
        // 当容器的元素类型是类、结构体这样的复合数据类型时，"<"运算符必须有定义
        // 优先队列默认情况下根据"<"运算符来决定元素的大小
        // 可以通过less<int>, greater<int>或在结构体cmp中自定义比较函数来实现小顶堆或大顶堆
        // 	priority_queue<int, vector<int>, less<int>> pqueue;	大顶堆(默认)
        // 	priority_queue<int, vector<int>, greater<int>> pqueue;	小顶堆
        template<class T, class Sequence = vector<T>>
        class priority_queue
        {
            ...;
        };
        ```
* 容器适配器所支持的操作：
  
    (S是一种容器适配器类型，s1, s2是S的两个实例，T是容器中的元素类型，t是T类型的一个实例)
    
    ```C++
    // 都支持的操作：
    s1 op s2;
    s.size();
    s.empty();
    s.push();
    s.pop();		// 弹出一个元素(栈：最后被压入的；队列：最先被压入的；优先队列：最值)
    
    // 栈支持的操作：
    s.top();		// 返回栈顶元素的引用
    
    // 队列支持的操作：
    s.front();		// 返回队首元素的引用
    s.back();		// 返回队尾元素的引用
    
    // 优先队列支持的操作：
    s.top();		// 获得下一个即将被弹出元素(即最"大"元素的引用)
    // 优点队列不支持比较操作：s1 op s2
    ```
    
* Note：容器适配器不支持迭代器，因为他们不允许对任意元素进行访问；
  
* 程序实例1：利用栈反向输出单词
  
    ```C++
    #include <stack>
    #include <iostream>
    #include <string>
    using namespace std;
    
    int main()
    {
        stack<char> s;
        string str;
        cin >> str;
        
        for(string::iterator iter = str.begin(); iter != str.end(); ++iter)
            s.push(*iter);
        
        while(!s.empty())
        {
            cout << s.top();
            s.pop();
        }
        cout << endl;
        
        return 0;
    }
    
    // string类事实上也是一种随机访问容器，vector<char>具有的大部分功能它都具有(除了pop_back)
    ```
    
* 程序实例2：细胞分裂模拟
  
    ```C++
    #include <queue>
    #include <iostream>
    #include <cstdlib>
    #include <ctime>
    using namespace std;
    
    const int SPLIT_TIME_MIN = 500;
    const int SPLIT_TIME_MAX = 2000;
    
    class Cell;
    priority_queue<Cell> cellQueue;
    
    class Cell
    {
        private:
       		static int count;
        	int id;
        	int time;
        
        public:
       		Cell(int birth):id(count++)
            {
                time = birth + (rand()%(SPLIT_TIME_MAX - SPLIT_TIME_MIN))
                    + SPLIT_TIME_MIN;
            }
        	
        	int getId() const {return id;}
        	int getSplitTime() const {return time;}
        	bool operator<(const Cell& s) const {return time > s.time}
        
        	void split()
            {
                Cell child1(time), child2(time);
                cout << time << "s:Cell #" << id << " splits to #"
                    << child1.getId() << " and #" << child2.getId() << endl;
                cellQueue.push(child1);
                cellQueue.push(child2);
            }
    };
    int Cell::count = 0;
    
    int main()
    {
        srand(static_cast<unsigned>(time(0)));
        int t;
        cout << "Simulation time: ";
        cin >> t;
        
        cellQueue.push(Cell(0));
        while(cellQueue.top().getSplitTime() <= t)
        {
            cellQueue.top().split();
            cellQueue.pop();
        }
        
        return 0;
    }
    ```



### 10.3.3 关联容器

1. 顺序容器与关联容器：

    * 顺序容器：其元素顺序由程序员决定，程序员可以随意指定新元素的插入位置；
* 关联容器：每个元素都有一个键(key)，元素的顺序并不能由程序员决定，而是按照键的取值升序排序；
    * 特点：(可以高效地根据键来查找容器中的一个元素)
    * 对于关联容器s，使用迭代器在区间[s.begin(), s.end())区间内遍历，访问得到的序列总是升序；即s.begin()所指向的元素总是最小的，s.end()-1所指向的元素总是最大的；
    
2. 关联容器(associative container)的子概念：

    * 按照容器中是否允许出现重复键值：

        * 单重关联容器(unique associative container)：键值是唯一的，不允许重复(集合&映射)；
        * 多重关联容器(multiple associative container)：相同的键值允许重复出现(多重集合&多重映射)；

    * 按照键和元素的关系：

        * 简单关联容器(simple associative container)：

            * 以元素本身作为键(集合&多重集合)；
            * 只有一个类型参数，该类型既是键类型，又是容器类型；(set\<int>, multiset\<string>)

        * 二元关联容器(pair associative container)：

            * 元素由键和某种类型的附加数据共同组成，键只是元素的一部分(映射&多重映射)；

            * 有两个类型参数，前一个是键类型，后一个是附加数据的类型；(map<int, double>, multimap<string, int>)

            * 二元关联容器的元素类型是键类型和附加数据类型的组合，可用二元组(pair)来表示：

                ```C++
                // pair是<utility>头文件中定义的结构体模板
                template<class T1, class T2>
                struct pair
                {
                    T1 first;
                    T2 second;
                    pair();		// 默认构造函数
                    pair(const T1& x, const T2& y);		// 构造函数
                    template<class U, class V> pair(const pair<U, V>& p);	// 复制构造函数
                };
                ```

3. 关联容器的键之间必须能用"<"比较大小：

    * 如果键的类型是int, double等基本数据类型，由于它们具有内置的比较运算符，比较操作可自然完成；

    * 如果键的类型是类类型，则需要重载"<"运算符；
    * 对"<"重载的条件限制：
        * 非自反性：对任何对象x, x < x必须返回false；
        * "<"传递性：若x < y, y < z都返回true，则x < z必须返回true；
        * "=="传递性：若x == y, y == z都返回true，则x == z必须返回true；

4. 关联容器的基本功能：

    (S表示容器类型名，s表示S类型的实例；T表示S容器的元素类型，t表示T类型的实例；K表示S容器的键的类型，k表示K的一个实例；n表示一个整形数据；p1, p2表示指向s的元素的迭代器；q1, q2表示不指向s的元素的输入迭代器)

    * 构造函数：

        ```C++
        S s(q1, q2);	// 将[q1, q2)区间内的数据作为s的元素构造s
        
        // 单重关联容器：当[q1,q2)范围内出现具有相同键的元素时，只有第一个元素会被加入s中
        // 多重关联容器：[q1,q2)范围内所有元素均被无条件加入s中
        ```

    * 元素的插入：

        ```C++
        s.insert(t);		// 将元素t插入容器s中，返回一个二元组pair<S::iterator, bool>
        // 单重关联容器：
        	// 当不存在相同键值的元素时才能插入成功，返回被插入元素的迭代器和true；
        	// 否则返回与t的键相同的元素的迭代器和false；
        // 多重关联容器：插入总是会成功，返回被插入元素的迭代器；
        
        s.insert(p1, t);	// 将元素t插入容器s中，p1是一个提示的插入位置
        
        s.insert(q1, q2);	// 对区间[q1, q2)中的每个元素，分别执行s.insert(x)
        ```

    * 元素的删除：

        ```C++
        s.erase(p1);		// 删除p1指向的元素
        
        s.erase(p1, p2);	// 删除[p1,p2)区间内的元素
        
        s.erase(k);			// 删除所有键值为k的元素，返回被删除的元素个数
        ```

    * 基于键的查找和计数：

        ```C++
        s.find(k);		// 在s中查找键值为k的元素，若找到，返回该元素的迭代器；若没找到，返回s.end()
        
        s.lower_bound(k);	// 返回s中第一个键值不小于k的元素的迭代器
        
        s.upper_bound(k);	// 返回s中第一个键值大于k的元素的迭代器
        
        s.equal_range(k);	// 得到一个区间[p1, p2)，这个区间刚好包含所有键值为k的元素
        
        s.count(k);			// 返回s中键值为k的元素的个数
        ```

    * Note：

        * 关联容器的插入和删除操作不会使任何已有的迭代器、指针或引用失效；

5. 集合(set)：

    * 特点：

        * 集合由不重复的元素构成；
        * 集合的元素个数必须是有限的；
        * 集合中的元素是有序的，可以用来高效地查找指定元素；

    * 程序实例：输入一串实数，将重复的去掉，取最大和最小者的中值，分别输出小于等于此中值和大于等于此中值的实数

        ```C++
        #include <set>
        #include <iterator>
        #include <utility>
        #include <iostream>
        using namespace std;
        
        int main()
        {
            set<double> s;
            while(true)
            {
                double v;
                cin >> v;
                if(v == 0) break;
                pair<set<double>::iterator, bool> r = s.insert(v);
                if(!r.second)
                    cout << v << "is duplicated" << endl;
            }
            
            set<double>::iterator iter1 = s.begin();
            set<double>::iterator iter2 = s.end();
            double medium = (*iter1 + *(--iter2))/2;
            
            cout << "<= medium : ";
            copy(s.begin(), s.upper_bound(medium), ostream_iterator<double>(cout, " "));
            cout << endl;
            
            cout << ">= medium : ";
            copy(s.lower_bound(medium), s.end(), ostream_iterator<double>(cout, " "));
            cout << endl;
            
            return 0;
        }
        ```

6. 映射(map)：

    * 特点：

        * 与集合同属单重关联容器，因此用法十分相似；
        * 主要区别：集合的元素类型是键本身，而映射的元素类型是由键和附加数据所构成的二元组；
        * 在集合中按键查找一个元素时，用来确定该元素是否存在；而在映射中按键查找一个元素时，除了能确定它的存在性，还能得到相应的附加数据；

    * 程序实例1：有5门课程，每门都有相应的学分，从中选择三门，输出学分总和。

        ```C++
        #include <iostream>
        #include <map>
        #include <string>
        #include <utility>
        using namespace std;
        
        int main()
        {
            map<string, int> course;
            
            course.insert(make_pair("CSAPP", 3));
            course.insert(make_pair("C++", 2));
            course.insert(make_pair("CSARCH", 4));
            course.insert(make_pair("COMPLIER", 4));
            course.insert(make_pair("OS", 5));
            
            int n = 3;
            int sum;
            while(n>0)
            {
                string name;
                cin >> name;
                map<string, int>::iterator iter = course.find(name);
                if(iter == course.end())
                {
                    cout << name << " is not available" << endl;
                }
                else
                {
                    sum += iter->second;
                    course.erase(iter);
                    n--;
                }
            }
            
            cout << "Total credit : " << sum << endl;
            return 0;
        }
        ```

    * Note：

        * 二元组的生成：

            * 通过pair的构造函数：

                ```C++
                s.insert(pair<string, int>("CSAPP", 3));
                // 需要把键类型和附加数据类型都显式给出，比较繁琐
                ```

            * 通过使用make_pair函数：

                ```C++
                // make_pair是<utility>中定义的一个专用于辅助二元组构造的函数模板
                // 不需要显式给出键类型和附加数据类型，可以自动推导获得，比较简洁，使用较多
                template<class T1, class T2>
                pair<T1, T2> make_pair(T1 v1, T2 v2) {return pair<T1, T2>(v1, v2);}
                ```

        * 通过键来删除元素 & 通过迭代器来删除元素：

            ```C++
            course.erase(name);		// 通过键删除
            course.erase(iter);		// 通过迭代器删除
            
            // 通过键来删除元素，比用迭代器来删除元素的效率低
            // (因为通过键来删除首先得查找元素，而通过迭代器可以直接定位元素)
            ```

        * "[]"运算符(用来插入和查找元素)：

            * 需要在映射s中获得键值为k的元素的附加数据：s[k]；
            * 需要添加或改写键为k的元素的附加数据：为s[k]赋值；
            * s[k]操作：在s中查找键为k的元素，如果存在，则返回它的附加数据的引用；如果不存在，则向s中插入一个新元素并返回该元素附加数据的引用，该附加数据的初值为V()，其中V是附加数据类型；

    * 程序实例2：统计一句话中每个字母出现的次数。

        ```C++
        #include <iostream>
        #include <map>
        #include <cctype>
        using namespace std;
        
        int main()
        {
            map<char, int> s;
            char c;
            
            do
            {
                cin >> c;
                if(isalpha(c))
                {
                    c = tolower(c);
                    s[c]++;
                }
            }
            while(c != '.');
            
            for(map<char, int>::iterator iter = s.begin(); iter != s.end(); ++iter)
                cout << iter->first << " " << iter->second << " ";
            cout << endl;
            
            return 0;
        }
        ```

    * Note：

        * "isalpha"函数用于判断一个字符是否为字母；
        * "tolower"函数用于获得一个字符的小写字母形式(将大写字母转换为小写字母，其他字符原样返回)；
        * "isalpha"、"tolower"都定义在\<cctype>头文件中；
        * "[]"虽然直观方便，但不可完全替代insert, find函数。因为它会自动创建新元素，因而无法判断容器中是否具有指定键的元素；

7. 多重集合(multiset)与多重映射(multimap)：

    * 多重集合：允许有重复元素的集合；

    * 多重映射：允许一个键对应多个附加数据的映射；

    * Note：

        * 对于多重关联容器，一般较少使用find函数，而较多使用equal_range和count函数；
        * 映射所支持的"[]"不被多重映射支持，因为一个键不能对应唯一一个元素；

    * 程序实例：上课时间查询

        ```C++
        #include <iostream>
        #include <map>
        #include <utility>
        #include <string>
        using namespace std;
        
        int main()
        {
            multimap<string, string> course;
            typedef multimap<string, string>::iterator CourseIter;
            
            course.insert(make_pair("C++", "2-6"));
            course.insert(make_pair("COMPILER", "3-1"));
            course.insert(make_pair("COMPILER", "5-2"));
            course.insert(make_pair("OS", "1-2"));
            course.insert(make_pair("OS", "4-1"));
            course.insert(make_pair("OS", "5-5"));
            
            string name;
            int count;
            do
            {
                cin >> name;
                count = course.count(name);
                if(count == 0)
                    cout << "Cannot find this course!" << endl;
            }while(count == 0);
            
            cout << count << "lesson(s) per week : ";
            pair<CourseIter, CourseIter> range = course.equal_range(name);
            for(CourseIter iter = range.first; iter != range.second; ++iter)
                cout << iter->second << " ",
            cout << endl;
            
            return 0;
        }
        ```



## 10.4 函数对象

1. 引出：
    * 具体的容器类型被抽象成通用的容器框架，框架会依赖于一些基本的函数，根据具体的问题替换这些函数，便能实现具体的容器；
    * 一般的函数调用传递的是对象的值或引用，要传递函数，只能借助于函数对象；



### 10.4.1 函数对象基本概念及其分类

1. 作用：

    * 函数对象(function object 或 functor)是STL提供的一类主要组件，它使得STL的应用更加灵活方便，从而增加了算法的通用性；(大多数STL算法可以用一个函数对象作为参数)

2. 定义：

    * 一个行为类似函数的对象。可以不需要参数，也可以带有若干个参数。其功能是获取一个值，或改变操作的状态；
    * 任何普通的函数和重载了调用运算符operator()运算符的类的对象都可以作为函数对象；

3. 分类：(参考书P.436 图10-9)

    * 产生器(generator)、一元函数(unary function)、二元函数(binary function)；
    * 一元谓词(unary predicate)、二元谓词(binary predicate)；

4. 自定义函数对象：

    (以数值算法accumulate为例来说明自定义函数对象的设计及使用)

    * accumulate原型声明：

        ```C++
        //************************************************
        //
        // 名称：accumulate
        //
        // 功能：对数组元素进行累积运算
        //
        // 两种重载形式：
        // 		1.以“+”运算符作为运算规则
        // 		2.允许用户通过传递给算法相应的函数对象来指定计算规则
        //
        // 参数说明：
        // 		1.[first, last)为累加的区间；
        // 		2.val为累加始值；
        // 		3.binaryOp为对应的累加函数(第二种重载形式)
        //
        //*************************************************
        
        template<class InputIterator, class Type>
        Type accumulate(InputIterator first, InputIterator last,
                       Type val)
        {
            while(first != last)
            {
                val += *first;
                ++first;
            }
            return val;
        }
        
        template<class InputIterator, class Type, class BinaryFunction>
        Type accumulate(InputIterator first, InputerIterator last,
                       Type val, BinaryFunction binaryOp)
        {
            while(first != last)
            {
                val = binaryOp(val, *first);
                ++first;
            }
            return val;
        }
        ```

    * 程序实例：利用普通函数来定义函数对象(实现连乘)

        ```C++
        #include <iostream>
        #include <numeric>
        using namespace std;
        
        int mult(int x, int y) {return x*y;}
        
        int main()
        {
            int a[] = {1, 2, 3, 4, 5};
            const int N = sizeof(a)/sizeof(int);
            cout << "The result by multipling all elements in a is "
                << accumulate(a, a+N, 1, mult) << endl;
            
            return 0;
        }
        ```

    * 程序实例：利用类来定义函数对象(实现连乘)

        ```C++
        #include <iostream>
        #include <numeric>
        using namespace std;
        
        class MutlClass
        {
            public:
            	int operator()(int x, int y) const {return x*y;}
        };
        
        int main()
        {
            int a[] = {1, 2, 3, 4, 5};
            const int N = sizeof(a)/sizeof(int);
            cout << "The result bu multipling all elements in a is "
                << accumulate(a, a+N, 1, MutlClass()) << endl;
            return 0;
        }
        
        // 通过在类MutlClass中重载运算符operator()，就定义了一种可以作为函数参数的对象；
        // 使用类的形式定义的函数对象能够比普通函数携带更多的额外信息；？？？
        ```

5. 标准函数对象：

    - 产生器(generator)、一元函数(unary function)、二元函数(binary function)：

        * 定义：

            * 产生器：0个传入参数；
            * 一元函数：1个传入参数；
            * 二元函数：2个传入参数；

        * STL标准库中一元函数对象：

            * negate\<T>：输入一个类型为T的操作数x，返回-x；
            
        * STL标准库中二元函数对象：(参考书P.438 图10-4)
    
            * plus\<T>：输入两个类型为T的操作数x, y，返回x+y；
            * minus\<T>：输入两个类型为T的操作数x, y，返回x-y；
            * multiplies\<T>：输入两个类型为T的操作数x, y，返回x*y；
            * divides\<T>：输入两个类型为T的操作数x, y，返回x/y；
            * modulus\<T>：输入两个类型为T的操作数x,y，返回x%y；
* Note：
  
    * 为了调用标准函数对象，需要包含头文件\<functional>；
    
    * 标准函数对象是内联函数；
      
    * 程序实例：利用STL标准函数对象实现连乘
      
        ```C++
        #include <iostream>
        #include <numeric>
        #include <functional>
        using namespace std;
        
        int main()
        {
            int a[] = {1, 2, 3, 4, 5};
            const int N = sizeof(a)/sizeof(int);
            
            cout << "The result by multipling all elements in a is "
                << accumulate(a, a+N, 1, multiplies<int>()) << endl;
            
        return 0;
        }
        ```
    
- 一元谓词(unary predicate)、二元谓词(binary predicate)：
  
    * 定义：返回值为bool类型，具有一个或两个参数，称为谓词函数对象；
    
    * 作用：用于判断是否为真、比较大小；
    
        * STL标准函数库中的谓词函数对象：(参考书P.439 图10-5)
    
            * equal_to\<T>：x == y
            * not_equal_to\<T>：x != y
            * greater\<T>：x > y
            * less\<T>：x < y
            * greater_equal\<T>：x >= y
            * less_equal\<T>：x <= y
            * logical_and\<T>：x && y
            * logical_or\<T>：x || y
            * logical_not\<T>：!x
        
    * 程序实例：利用STL中的二元谓词函数对象
      
        ```C++
        #include <functional>
        #include <iostream>
        #include <vector>
        #include <algorithm>
        using namespace std;
        
        int main()
        {
            int intArr[] = {30, 90, 10, 40, 70, 50, 20, 80};
            const int N = sizeof(intArr)/sizeof(int);
            vector<int> a(intArr, intArr+N);
            
            cout << "Before sorting:" << endl;
            copy(a.begin(), a.end(), ostream_iterator<int>(cout, "\t"));
            cout << endl;
            
            sort(a.begin(), a.end(), greater<int>());
            
            cout << "After sorting:" << endl;
            copy(a.begin(), a.end(), ostream_iterator<int>(cout, "\t"));
            cout << endl;
            
            return 0;
        }
        
        // 默认情况下，sort算法使用less比较器进行比较，从而将数组从小到大排序
        // 此例将greater函数对象代入sort算法框架，实现了数组从大到小排序
        ```
        
    
- 关联类型(associated types)：
  
    * 目的：在STL中，定义了两个函数对象的基类unary_function, binary_function，分别用于设计一元和二元函数对象；
    
    * 作用：任何函数对象，只要继承相应的基类，便自动拥有了相应的关联类型的特征信息；
    
        * unary_function, binary_function的定义：
    
            ```C++
            // unary_function
            template<class Arg, class Result>
            struct unary_function
            {
                typedef Arg argument_type;
                typedef Result result_type;
            };
            
            // binary_function
            template<class Arg1, class Arg2, class Result>
            struct binary_function
            {
                typedef Arg1 first_argument_type;
                typedef Arg2 second_argument_type;
                typedef Result result_type;
            }
            ```



### 10.4.2 函数适配器

1. 问题：有时需要对函数返回值进行进一步简单处理，或者填上多余的参数，不能直接代入算法；

2. 解决方法：使用函数适配器；

3. 作用：将一种函数对象转化为另一种符合要求的函数对象；

4. 分类：
    * 绑定适配器(bind adaptor)：

        * 分类：
            * binder1st：将数值绑定到二元函数的第一个参数，适配成一元函数；
            * binder2nd：将数值绑定到二元函数的第二个参数，适配成一元函数；

        * 以find_if算法为例进行说明：

            * find_if算法原型：

                ```C++
                // 功能：查找数组[first, last)区间中第一个pred()为真的元素
                //		若找到，返回该元素的迭代器；若没找到，返回s.end()
                
                template<class InputerIterator, class UnaryPredicate>
                InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);
                ```

            * binder2nd类：

                * 继承自unary_function，在类的函数运算体中完成对二元函数的参数传递和调用；

                * 通常用辅助函数bind2nd构造binder2nd，产生它的一个实例：

                    ```C++
                    // bind2nd原型声明:
                    
                    template<class BinaryFunction, class Type>
                    binder2nd<BinaryFunction> bind2nd(const BinaryFunction& func,
                                                     const Type& right);
                    // 只要传入二元函数对象func和绑定数值right便能生成binder2nd类型的实例
                    ```

            * 程序实例：bind2nd产生binder2nd函数适配器实例

                ```C++
                #include <iostream>
                #include <functional>
                #include <vector>
                #include <algorithm>
                using namespace std;
                
                int main()
                {
                    int intArr[] = {30, 90, 10, 40, 70, 50, 20, 80};
                    const int N = sizeof(intArr)/sizeof(int);
                    vector<int> a(intArr, intArr+N);
                    vector<int>::iterator p = find_if(a.begin(), a.end(),
                                                      bind2nd(greater<int>(), 40));
                    if(p == a.end())
                        cout << "no element greater than 40" << endl;
                    else
                        cout << "first element greater than 40 is :" << *p << endl;
                    
                    return 0;
                }
                ```

    * 指针函数适配器(pointer function adaptor)：

        * 问题：在进行参数绑定或者其他转换的时候，通常需要函数对象的类型信息，但如果传入的是指针函数形式的函数对象，则无法获得函数对象的类型信息；

        * 分类：

            * pointer_to_unary_function：将普通一元函数指针适配成unary_function
            * pointer_to_binary_function：将普通二元函数指针适配成binary_function

        * ptr_fun辅助函数：

            * 作用：构造pointer_to_unary_function、pointer_to_binary_function的实例；

            * ptr_fun函数原型：

                ```C++
                template<class Arg, class Result>
                pointer_to_unary_function<Arg, Result, Result (*)(Arg)>
                ptr_fun(Result (*pfunc)(Arg));
                
                template<class Arg1, class Arg2, class Result>
                pointer_to_binary_function<Arg1, Arg2, Result, Result (*)(Arg1, Arg2)>
                ptr_fun(Result (*pfunc)(Arg1, Arg2));
                ```

    * 组合适配器(composite adaptor)：

        * 作用：对于一般的逻辑运算，有时还需要对结果求一次逻辑反；

        * 分类：

            * unary_negate：将一元谓词的返回值适配成其逻辑反；
            * binary_negate：将二元谓词的返回值适配成其逻辑反；

        * not1、not2辅助函数：

            * 作用：辅助生成相应的函数对象实例；

            * not1, not2函数原型：

                ```C++
                template<class UnaryPredicate>
                unary_negate<UnaryPredicate> not1(const UnaryPredicate& pred);
                
                template<class BinaryPredicate>
                binary_negate<BinaryPredicate> not2(const BinaryPredicate& func);
                ```

        * 程序实例：ptr_fun, not1和not2产生函数适配器实例

            ```C++
            #include <functional>
            #include <iostream>
            #include <vector>
            #include <algorithm>
            using namespace std;
            
            bool g(int x, int y)
            {
                return x>y;
            }
            
            int main()
            {
                int intArr[] = {30, 90, 10, 40, 70, 50, 20, 80};
                const int N = sizeof(intArr)/sizeof(int);
                vector<int> a(intArr, intArr+N);
                
                vector<int>::iterator p;
                p = find_if(a.begin(), a.end(), bind2nd(ptr_fun(g), 40));
                if(p == a.end())
                    cout << "no element greater than 40" << endl;
                else
                    cout << "first element greater than 40 is :" << *p << endl;
                
                p = find_if(a.begin(), a.end(), not1(bind2nd(greater<int>(), 15)));
                if(p == a.end())
                    cout << "no element is not greater than 15" << endl;
                else
                    cout << "first element that is not greater than 15 is : " 
                    << *p << endl;
                
                p = find_if(a.begin(), a.end(), bind2nd(not2(greater<int>()), 15));
                if(p == a.end())
                    cout << "no element is not greater than 15" << endl;
                else
                    cout << "first element that is not greater than 15 is : "
                    << *p << endl;
                
                return 0;
            }
            ```

    * 成员函数适配器(member function adaptor)：

        * 问题：类的成员函数也是一种函数对象，但是设计实例指针，不能直接使用，需要把"object->method()"这种调用形式转化为"method(object)"形式；当成员函数有一个传入参数时，"object->method(arg1)"则对应于二元函数"method(object, arg1)"；

        * 模板函数for_each：

            ```C++
            // 功能：对迭代区间[first, last)中的每一个元素，都调用一次func(element)
            
            // 原型声明：
            template<class InputIterator, class UnaryFunction>
            Function for_each(InputIterator first, InputIterator last, UnaryFunction func);
            ```

        * mem_fun, mem_fun_ref辅助函数：

            ```C++
            // mem_fun, mem_fun_ref各有四种重载形式，分别对应一元或二元、常量或非常量函数的适配器
            
            // 一元常量函数的重载形式：
            
            // 传入对象实例的指针
            template<class Result, class Type>
            const_mem_fun_t<Result, Type> mem_fun(Result (Type::*pm) () const);
            
            // 传入对象实例的引用
            template<class Result, class Type>
            const_mem_fun_ref_t<Result, Type> mem_fun_ref(Result (Type::*pm) () const);
            ```

        * 程序实例：成员函数适配器实例

            ```C++
            #include <functional>
            #include <iostream>
            #include <vector>
            #include <algorithm>
            using namespace std;
            
            struct Car
            {
                int id;
                Car(int id) {this->id = id;}
                void display() const {cout << "car" << id << endl;}
            };
            
            int main()
            {
                vector<Car*> pcars;
                vector<Car> cars;
                
                for(int i = 0; i < 5; i++)
                    pcars.push_back(new Car(i));
                for(int i = 5; i < 10; i++)
                    cars.push_back(Car(i));
                
                cout << "elements in pcars : " << endl;
                for_each(pcars.begin(), pcars.end(), mem_fun(&Car::display));
                cout << endl;
                
                cout << "elements in cars : " << endl;
                for_each(cars.being(), cars.end(), mem_fun_ref(&Car::display));
                cout << endl;
                
                for(size_t i = 0; i < pcars.size(); i++)
                    delete pcars[i];
                
                return 0;
            }
            ```



## 10.5 算法

1. 概述：

    * 算法通过迭代器来访问容器中的元素；
    * 算法无需知道元素是什么，存储在何处；
    * 算法集中于解决问题；

2. 算法的通用性：

    * 每种算法都适合于若干种不同的数据结构；

        (用户可以在自己定义的数据结构上应用算法， 只需要让自定义容器的迭代器类型满足算法要求)

3. 算法的分类：

    * 不可变序列算法：这类算法在对容器操作时，不会改变容器的内容；
    * 可变序列算法：会改变所操作容器的内容；
    * 排序和搜索算法：
    * 数值算法：



### 10.5.1 STL算法基础

1. 算法输入：通常需要给出一个区间和一个运算函数或值；
2. 算法操作：根据区间内的元素计算出某种数值或对区间内的元素进行某种操作；



### 10.5.2 不可变序列算法

1. 定义：(non-mutating algorithms)指那些不直接修改所操作的容器内容的算法；

2. 分类：

    * 查找：
    * 相等检查：
    * 计数：

3. 不可变序列算法列表：

4. 常用算法说明：

5. 程序实例：不可变序列算法应用实例

    ```C++
    #include <iostream>
    #include <functional>
    #include <algorithm>
    #include <vector>
    using namespace std;
    
    int main()
    {
        int iarray[] = {0, 1, 2, 3, 4, 5, 6, 6, 6, 7, 8};
        vector<int> ivector(iarray, iarray + sizeof(iarray)/sizeof(int));
        
        int iarray1[] = {6, 6};
        vector<int> ivector1(iarray1, iarray1 + sizeof(iarray1)/sizeof(int));
        
        int iarray2[] = {5, 6};
        vector<int> ivector2(iarray2, iarray2 + sizeof(iarray2)/sizeof(int));
        
        int iarray3[] = {0, 1, 2, 3, 4, 5, 7, 7, 7, 9, 7};
        vector<int> ivector3)(iarray3, iarray3 + sizeof(iarray3)/sizeof(int));
        
        cout << *adjacent_find(ivector.begin(), ivector.end()) << endl;
        // 查找相邻且重复的元素
        // Output: 6
        
        cout << count_if(ivector.begin(), ivector.end(), bind2nd(less<int>(), 7))
            << endl;
        // 找出小于7的元素的个数
        // Output: 9
        
        count << *find_if(ivector.begin(), ivector.end(), bind2nd(greater<int>(), 2))
            << endl;
        // 找到第一个大于2的元素
        // Output: 3
        
        count << *search(ivector.begin(), ivector.end(), ivector2.begin(),
                         ivector2.end()) << endl;
        // 找出子序列ivector2在序列ivector中出现的起点位置的元素
        // Output: 5
        
        cout << *search_n(ivector.beign(), ivector.end(), 3, 6, equal_to<int>()) << endl;
        // 找出连续出现3个6的起点位置的元素
        // Output: 6
        
        cout << equal(ivector.begin(), ivector.end(), ivector3.begin()) << endl;
        // 判断两个区间ivector和ivector3是否相等(0为假，1为真)
        // Output: 0
        
        pair<vector<int>::iterator, vector<int>::iterator> result =
            mismatch(ivector.begin(), ivector.end(), ivector3.begin());
        cout << result.first - ivector3.begin() << endl;
        // 查找区间ivector3在ivector中不匹配点的位置
        // Output: 6
        
        return 0;
    }
    ```



### 10.5.3 可变序列算法

1. 定义：可变序列算法(mutating algorithm)可以修改它们所操作容器的元素；

2. 分类：

    * 复制(copy)
    * 生成(generate)
    * 删除(remove)
    * 替换(replace)
    * 倒序(reverse)
    * 旋转(rotate)
    * 交换(swap)
    * 变换(transform)
    * 分割(partition)
    * 去重(unique)
    * 填充(fill)
    * 洗牌(shuffle)

3. 程序实例：可变序列算法应用实例

    ```C++
    #include <iostream>
    #include <algorithm>
    #include <functional>
    #include <iterator>
    #include <vector>
    using namespace std;
    
    class evenByTwo
    {
        private:
        	int x;
        public:
        	evenByTwo(): x(0) {}
        	int operator()() {return x += 2;}
    };
    
    int main()
    {
        int iarray1[] = {0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 8};
        int iarray2[] = {0, 1, 2, 3, 4, 5, 6, 6, 6, 7, 8};
        vector<int> ivector1(iarray1.begin(), iarray1 + sizeof(iarray1)/sizeof(int));
        vector<int> ivector2(iarray2.begin(), iarray2 + sizeof(iarray2)/sizeof(int));
        vector<int> ivector3(2);
        
        ostream_iterator<int> output(cout, " ");
        
        fill(ivector3.begin(), ivector.end(), -1);
        copy(ivector3.begin(), ivector3.end(), output);
        cout << endl;
        
        generate(ivector3.begin(), ivector3.end(), evenByTwo());
        copy(ivector3.begin(), ivector3.end(), output);
        cout << endl;
        
        vector<int> ivector4;
        remove_copy(ivector2.begin(), ivector2.end(), back_inserter(ivector4), 6);
        copy(ivector4.begin(), ivector4.end(), output);
        cout << endl;
        
        ivector2.erase(remove_if(ivector2.begin(), ivector2.end(), bind2nd(less<int>(), 6)), ivector2.end());
        copy(ivector2.begin(), ivector2.end(), output);
        cout << endl;
        
        replace(ivector2.begin(), ivector2.end(), 6, 3);
        copy(ivector2.begin(), ivector2.end(), output);
        cout << endl;
        
        reverse(ivector2.begin(), ivector2.end());
        copy(ivector2.begin(), ivector2.end(), output);
        cout << endl;
        
        rotate_copy(ivector2.begin(), ivector2.begin()+3, ivector2.end(), output);
        cout << endl;
        
        return 0;
    }
    ```



### 10.5.4 排序和搜索算法

1. 排序算法：

    * sort算法：

        ```C++
        // sort算法原型(两种重载形式)
        
        template<class RandomAccessIterator>
        void sort(RandomAccessIterator first, RandomAccessIterator last);
        
        template<class RandomAccessIterator, class UnaryPredicate>
        void sort(RandomAccessIterator first, RandomAccessIterator last, UnaryPredicate comp);
        ```

    * stable_sort算法：

        * 原型与sort几乎完全相同；
        * 与sort的不同：对于相等数值的元素，排序前后相对位置将保持不变；
        * stable_sort可用于多关键字同时排序的场合，当字段1相等时按照字段2排序；

    * partical_sort算法：

        ```C++
        //******************************************************
        // 功能：对区间[first, last)中的部分数进行排序
        //			[sortEnd, last)中的数比其余的数大，当相对顺序不变；
        //			[first, sortEnd)中的数将按从小到大排序；
        //
        // 使用场合：当仅需要取出前k个较小的数并排序时
        //******************************************************
        
        // partical_sort算法原型(两种重载形式)：
        template<class RandomAccessIterator>
        void partical_sort(RandomAccessIterator first, RandomAccessIterator sortEnd,
                           RandomAccessIterator last);
        
        template<class RandomAccessIterator>
        void partical_sort(RandomAccessIterator first, RandomAccessIterator sortEnd,
                           RandomAccessIterator last, BinaryPredicate comp);
        ```

2. 最值算法：

    * min_element：用于计算迭代区间中的最小元素

        ```C++
        template<class ForwardIterator>
        ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
        ```

    * max_element：用于计算迭代区间中的最大元素

        ```C++
        template<class ForwardIterator>
        ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
        ```

3. 程序实例：排序与搜索算法实例

    ```C++
    
    ```



### 10.5.6 数值算法





## 10.6 综合实例：个人银行账户管理程序





## 10.7 深度探索