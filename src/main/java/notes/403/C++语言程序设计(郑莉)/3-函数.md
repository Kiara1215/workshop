[TOC]

# 第三章 函数



## 3.1 函数的定义与使用

### 3.1.1 函数的定义

1. 函数定义的语法形式：

   ```C++
   类型说明符 函数名(含类型说明符的形式参数表)
   {
       语句序列
   }
   ```

2. 形式参数：

   * 形参表：

       ```C++
       type1 name1, type2 name2, ...
       ```

   * main函数的形参：

       ```C++
// main函数可以有形参，其形参也称命令行参数，由操作系统在启动程序时初始化
       int main(int argc, char* argv[]);
       ```
   
3. 函数的返回值和返回类型：

   * 函数可以有一个返回值，函数的返回值是需要返回给主调函数的处理结果；
   
   * 类型说明符规定了函数返回值的类型；
   
   * 函数的返回值由return语句给出；
   
       ```C++
       return 表达式;
       ```
   
   * return 除了指定函数的返回值外，还有一个作用是结束当前函数的执行；
   
   * main函数的返回值最终传递给操作系统；
   
   * 一个函数也可以不将任何值返回给主调函数，返回类型为void，可以不写return语句，也可以只写不带表达式的return语句，用于结束当前函数的调用；



### 3.1.2 函数的调用

1. 函数的调用形式：

   * 函数在调用之前需要声明(函数的定义属于函数声明)；

   * 声明函数或者变量，只是将函数或变量的有关信息告诉编译器，编译时不产生任何目标代码；

   * 若要在一个函数定义前调用它，则需要在调用该函数之前添加该函数的函数原型声明，形式如下：

     ```C++
     类型说明符 函数名(含类型说明的形参表);
     ```

   * 声明函数时，形参表只要包含完整的类型信息即可，形参名可以省略，但不推荐这种写法(可读性差)；

   * 如果在所有函数之前声明了函数原型，那么该函数原型在本程序文件的任何地方都有效；如果只在主调函数内部声明了被调函数原型，那么该函数原型只在主调函数内部有效；(作用域与可见性问题)

2. 嵌套调用：

   * 定义：函数1调用函数2，函数2再调用函数3；

3. 递归调用：

   * 定义：函数直接或间接地调用自身，称为递归调用；
   * 实质：将原有问题分解为新的问题，而解决新问题时又用到了原有问题的解法；
   * 过程：
     * 递推：从未知到已知；
     * 回归：从已知到未知；
   * Note：
       * 对同一个函数的多次不同调用中，编译器会为函数的形参和局部变量分配不同的空间，它们之间互不影响；(函数调用栈)

4. 程序实例：3_1 ~ 3_10



### 3.1.3 函数的参数传递

1. 值传递：

   * 实质：由实参到形参的单向传递；

   * 程序实例：

       ```C++
       // 3_11.cpp
       
       #include <iostream>
       using namespace std;
       
       void swap(int x, int y)
       {
           int tmp = x;
           x = y;
           y = tmp;
       }
       
       int main()
       {
           int x = 5, y = 10;
           cout << "x = " << x << " y = " << y << endl;
           swap(x, y);
           cout << "x = " << x << " y = " << y << endl;
           return 0;
       }
       ```

2. 引用传递：
   * 引用：
     
     * 实质：可以被认为是变量的别名，但其实是变量的地址；
     
     * Note：
     
         * 声明一个引用时，必须同时对它进行初始化，使它指向一个已经存在的对象；
         * 一旦一个引用被初始化后，就不能改为指向其他对象；
     
     * 举例：
     
         ```C++
         int i, j;
         int& ri = i;	// 建立一个指向i的引用ri
         j = 10;
         ri = j;			// 相当于i = j
         ```
     
   * 实质：双向传递；

   * 程序实例：

       ```C++
       // 3_12.cpp
       
       #include <iostream>
       using namespace std;
       
       void swap(int& x, int& y)
       {
           int tmp = x;
           x = y;
           y = tmp;
       }
       
       int main()
       {
       	int x = 5, y = 10;
           cout << "x = " << x << " y = " << y << endl;
           swap(x, y);
           cout << "x = " << x << " y = " << y << endl;
           return 0;
       }
       ```

       ```C++
       // 3_13.cpp 引用传递与值传递的比较
       ```

3. 值传递与引用传递的比较：
    * 值传递是单向传递，引用传递是双向传递；
    * 引用传递的实质是传递地址，因此对于较大的对象，引用传递的开销更小；



## 3.2 内联函数(Inline Function)

1. 使用函数的优缺点：

   * 优点：有利于代码重用、可以提高开发效率、增强程序的可读性、便于分工合作、便于维护修改；
   * 缺点：降低程序的执行效率、增加时间和空间方面的开销；

2. 内联函数使用原则：将功能简单、规模较小、使用频繁的函数定义为内联函数；

3. 内联函数原理：编译时将函数体嵌入每一个调用处；

4. Note : 

   * inline关键字应放在函数定义处，而不应该放在函数声明处；
   * inline关键字是用于实现的关键字，不是用于声明的关键字；(用户没有必要，也不应该知道函数是否内联)
   * 使用inline函数虽然能加速程序运行，但是也会使代码膨胀，是一种用空间来换时间的策略；
   * 内联函数的定义一般放在头文件中；
   * 类声明中定义的函数自动成为内联函数；
5. 参考资料：[C++内联函数](https://blog.csdn.net/u011327981/article/details/50601800)



## 3.3 带默认形参值的函数

1. 概述：

    * 函数在定义时可以预先声明默认的形参值；

    * 调用时若给出实参，则用实参初始化形参；

    * 如果没给出实参，则采用预先声明的默认形参值；

    * 举例：

        ```C++
        int add(int x = 5, int y = 6)
        {
            return x+y;
        }
        
        int main()
        {
            add(10, 20);
            add(10);
            add();
            return 0;
        }
        ```

2. Note：

    * 有默认值的形参必须在无默认值形参的后面；

        ```C++
        int add(int x, int y = 10, int z = 20); 	// ok
        int add(int x = 10, int y, int z = 20);		// error
        ```

    * 在相同的作用域内，不允许在同一个函数的多个声明中对同一个形参的默认值重复定义，即使前后定义的值相同也不行；(函数定义也是函数声明)

        ```C++
        int add(int x = 5, int y = 6);		// 默认形参在函数原型中给出
        
        int main()
        {
            add();
            return 0;
        }
        
        // 这里不能在出现默认形参，但为了清晰，可以通过注释说明默认形参
        int add(int x /* = 5*/, int y /* = 6 */)
        {
            return x+y;
        }
        ```

3. 程序实例：

    ```C++
    
    ```



## 3.4 函数重载

1. 重载的含义：

   * 生活中的一词多义；(擦桌子，擦皮鞋，擦窗户)

2. 函数重载：

   * 两个及以上的函数，具有相同的函数名，但形参列表不同(个数或类型不同)，编译器根据调用时实参和形参的最佳匹配，自动确定调用哪一个函数；

3. Note：
   * 重载函数的形参表必须不同(形参个数或类型不同)，与函数返回值类型无关；
   
       ```C++
    // 形参类型不同
       int add(int x, int y);
       float add(float x, float y);
       
       // 形参个数不同
       int add(int x, int y);
       int add(int x, int y, int z);
       ```
   
   * 使用具有默认形参值的函数重载时，需要注意防止二义性；
   
       ```C++
       void fun(int length, int width = 2, int height = 3);
       void fun(int length);
       
       fun(1);		// error:编译器无法确定应该执行哪个函数
       ```
   
   * 将功能相近的函数定义为重载，切勿将功能不同的函数定义为重载；
   
5. 程序实例：

   ```C++
   // 3_16.cpp
   ```



## 3.5 C++系统函数

1. 系统函数分为两类：

    * 标准C++函数："cmath", "cstdlib", "ctime", "cstdio"；
    * 非标准C++函数：Linux-"fork"；

2. Note：

    * 需要首先include相应的头文件，然后就可以使用相应的系统函数；
    * 编程时应优先使用标准C++函数(可移植性好)；
    * 有时也需要使用一些非标准C++函数，来处理操作系统相关的事务；

3. 参考资料：[C++标准函数](http://www.cppreference.com)

4. 程序实例：

    ```C++
    // 3_17.cpp
    // <cmath>头文件中包含了sin(), cos(), tan()函数原型
    
    ```



## 3.6 深度探索

### 3.6.1 运行栈与函数调用的执行

1. 栈和函数调用的特点：

   * 栈：后进先出LIFO(Last In First Out)；
   * 一组嵌套的函数的调用特点：越早开始的调用，返回的越晚；

2. 运行栈工作原理：

   * 运行栈中的数据分为一个个栈帧，每个栈帧对应一次函数调用；

   * 每发生一次函数调用时，都有一个栈帧被压入运行栈中，而调用返回后，相应的栈帧会被弹出；

   * 一个函数在执行过程中能够直接随机访问它所对应栈帧中的数据；

       (执行中函数的栈帧，总处在运行栈的最顶端)

   * 运行栈中有一部分主调函数和被调函数都能访问的公共空间，供主调函数与被调函数之间传递数据所用；

   * 函数在被调用时，形参和局部变量的地址不确定，但其相对于栈顶的地址是确定的，可以通过栈顶地址定位形参和局部变量；

3. 函数的调用和执行过程：(以IA-32为例)

   * 栈指针：指向栈顶位置；esp

   * 帧指针：指向栈底位置(函数刚被调用时栈指针的位置)；ebp

     (通常通过帧指针来计算函数形参和局部变量的地址，而非栈指针)



### 3.6.2 函数声明与类型安全

1. 函数声明的必要性：(与变量声明类似)

   * 一个函数的原型信息，并没有写在编译后的机器语言代码中，而是全部隐藏在该函数所执行的操作中；
   
2. Note：

   * 与C++不同，C语言中允许在调用函数之前只对函数进行不完整的声明(只声明函数名和返回类型，不声明参数类型)，甚至根本不声明；

   * 与C++不同，C语言中声明函数时，括号为空，并不表示这个函数没有参数，而是表示它所要求的参数是未知的。如果要声明一个没有参数的函数，应在括号中写入void；

   * 举例：

       ```C
       double add();
       
       int main()
       {
           double s = add(1, 2);
           return 0;
       }
       
       double add(double a, double b)
       {
           return a+b;
       }
       ```

