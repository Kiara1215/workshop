[TOC]

# 第二章 C++简单程序设计



## 2.1 C++语言概述

1. C++的产生:

    * C++是从C语言发展演变而来；
    * C++在C语言的基础上为支持面向对象的程序设计而研制；

2. C++的特点：

    * C++是一个更好的C(C++保持与C的兼容，同时保持了C的简洁高效、接近汇编语言等特点)；
    * C++既支持面向过程的程序设计，又支持面向对象的程序设计；

3. C++程序实例：

    ```C++
    // 2_1.cpp
    
    # include <iostream>
    using namespace std;
    
    int main(int argc, char** argv)
    {
        cout << "Hello!" << endl;
        cout << "Welcome to C++!" << endl;
        return 0;
    }
    ```

4. C++字符集：
    * 英文字母
    * 数字字符
    * 特殊字符
5. C++词法记号：
    * 关键字：C++中预先声明的单词；
    * 标识符：程序员定义的单词，命名程序正文中的一些实体；
        * C++标识符构成规则：
            - 以大小写字母或下划线开始；
            - 由大小写字母、数字、下划线组成；
            - 不能是C++关键字；
            - 区分大小写(大小写字母代表不同的标志符)；
    * 文字：程序中直接使用符号表示的数据；
    * 操作符：用于实现各种运算的符号；
    * 分隔符：用于分隔各个词法记号或程序正文；
    * 空白：
        * 在程序编译时的词法分析阶段将程序正文分解为词法记号和空白；
        * 空白包括：空格、制表符、回车符、换行符、注释；
        * 编译时忽略注释部分，所以注释内容不会影响最终产生的可执行程序的大小；



## 2.2 基本数据类型和表达式



### 2.2.1 基本数据类型

1. 基本数据类型：bool, char, int, float, double;
2. 修饰符：singed, unsigned, short, long;



### 2.2.2 常量

1. 定义：常量指程序运行过程中其值始终不可改变的量；
2. 分类：
    * 整形常量：(整形常量后可用l表示长整型，用u表示无符号整型)
        * 十进制：
        * 八进制：以0开头；
        * 十六进制：以0x开头；
    * 实型常量：(实型常量默认为double类型，如果后缀f可使其成为float型)
        * 一般形式：
        * 指数形式：
    * 字符常量：
        * 一般字符：
        * 不可显示字符：通过转义序列来表示；
        * (一般字符和不可显示字符都可以用八进制或十六进制ASCII码来表示：八进制：\nnn，十六进制：\xnnn)
    * 字符串常量：
        * 字符串常量简称字符串，是用一对双引号扩起来的字符序列；
        
        * 字符串与字符是不同的：**在末尾添加‘\0’作为结束标志**；
        
        * C++ 中有字符串常量，却没有字符串变量，可用string类来存储字符串；
        
        * 由于双引号是字符串的界限符，所以字符串中间的双引号就要用转义序列来表示；
        
            ```C++
            "Please enter \"Yes\" or \"No\""
            表示的是：
            Please enter "Yes" or "No"
            ```
    * bool常量：
        
        * true & false;



### 2.2.3 变量

1. 定义：在程序执行过程中其值可以变化的量称为变量，变量需要用名字来标识；
2. 变量的声明和定义：
    * 变量在使用前需要先声明其类型和名称；
    * 声明和定义：
        * 声明：将变量名标识符的有关信息告诉编译器，使编译器“认识”该标识符，不一定引起内存的分配；
        * 定义：给变量分配内存空间，用于存放对应类型的数据，变量名也就是相映内存单元的名称；
    * Note：
        * C++中大多数情况下，变量声明也就是变量定义，只有声明外部变量(extern)时例外；
        * C++ 中有字符串常量，却没有字符串变量，用string类来存储字符串；
3. 变量的存储类型：(变量除了具有数据类型外，还具有存储类型，存储类型决定了其存储方式；)
    * auto：采用堆栈方式分配内存空间，属于暂时性存储，其存储空间可以被若干变量多次覆盖使用；
    
        (通常不用显式声明)
    
    * register：存放在通用寄存器中；
    
        (对于使用很频繁的变量可声明为register，但数目不宜过多)
    
    * extern：在所有函数和程序段中都可引用；
    
    * static：在内存中是以固定地址存放的，在整个程序运行期间都有效；限定作用域在本文件内；



### 2.3.4 符号常量

1. 定义：除了直接用文字表示常量外，也可以为常量命名，这就是符号常量；

2. 符号常量在使用前一定要先声明：(符号常量在声明时一定要赋初值，而在程序中间不能改变其值)

    * 语法形式：

        ```C++
        const 数据类型说明符 常量名 = 常量值；
        
        数据类型说明符 const 常量名 = 常量值；
        ```

    * 示例：

        ```C++
        const float PI = 3.14;
        ```

3. 优势(与直接使用文字常量相比)：
   * 有利于提高程序的可读性；
   * 避免修改常量值带来的不一致性；



### 2.3.5 运算符与表达式

1. 运算符分类：

   * 算术运算符(+, -, *, /, %)：

       * 取余运算“%”只能用于整形操作数；
       * 当"/"用于两个整形数据相除时，其结果取商的整数部分，小数部分被自动舍弃；
       * 自增(++)/自减(--)运算的结果被用来继续参与其他操作时，前置和后置效果不同；
        * 前置：先自增/自减，再参与其他操作；
           * 后置：先参与其他操作，再自增/自减；
   
* 赋值运算符(assignment)：
       * 复合赋值运算符：+=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=；

       * 左值与右值：

           * 左值(lvalue)表达式：
       
               * 指向特定的内存位置的表达式；
            * 左值可以出现在赋值号的左边或右边；
           
           * 右值(rvalue)表达式：
           
            * 不指向特定的内存位置，临时存在的表达式；
               * 右值是不能对其进行赋值的表达式，只能出现在赋值号的右边，不能出现在左边；
           
           * 示例：
           
            ```C++
               int i = 0, j = 0;	// i, j 均为左值(因为它们都指向特定的内存位置)
               i = j + 3;			// j + 3 为右值，因为表达式(j + 3)不指向特定的内存位置，只是临时存在于内存中，不能有"j + 3 = ..."这样的赋值
               ```
    
   * 逗号运算符：
       * 使用形式：表达式1,表达式2, ..., 表达式n
       * 先求解表达式1，再求解表达式2，..., 最终结果为表达式n的值。
   
   * 逻辑运算符：
       * 关系运算符：<, <=, >, >=, ==, !=
       * 逻辑运算符：!, &&, ||；("&&"和"||"的短路特性)
   
   * 条件运算符：
     * 形式：表达式1? 表达式2 : 表达式3
     * 执行顺序：先计算表达式1。若表达式1的值为true，则求解表达式2，表达式2的值作为最终结果；若为false，则求解表达式3，表达式3的值作为最终结果；(短路特性)
     * 条件运算符的优先级高于赋值运算符，低于逻辑运算符；
   
   * sizeof运算符：
       * 用于计算某种类型的对象在内存中所占字节数；
       * 形式：sizeof(类型名) 或 sizeof(表达式)；
   
   * 位运算：
     
     * 限制：
         * 操作数必须是整数或字符型数据；
         * 对小数部分直接进行位运算没有意义；
     * 分类：
         * 按位与(&)：将两操作数的每一位分别进行逻辑与操作；
     
         * 按位或(|)：将两操作数的每一位分别进行逻辑或操作；
         * 按位异或(^)：若对应位相同，结果为0；若对应位不同，结果为1；
     
         * 按位取反(~)：对一个二进制数的每一位取反；
     
         * 移位：二元操作符，左边的操作数是需要移位的数值，右边的操作数是需要左移或右移的位数；
           * 左移(<<)：低位补0，移出的高位舍弃；
           * 右移(>>)：移出的地位舍弃，无符号数高位补0，有符号数高位补符号位；
           * Note：移位运算的结果是位运算表达式的值，移位运算符左边的表达式值并不会被改变；
   
2. 运算符的优先级与结合性：(参考：C traps and pitfalls)

   * 优先级：
   * 示例：

3. 混合运算时数据类型的转换：

   * 隐含转换：将低类型数据转换为高类型数据(在转换过程中数据精度没有损失)；

     * 逻辑运算符：操作数必须是bool类型。若操作数是其他类型，则非0转换为true，0转换为false；
     * 位运算符：操作数必须为整数；
     * 赋值运算符：一律将右值转换为左值；

   * 显示转换：将表达式的结果类型转换为另一种指定的类型；

     * 显示转换语法的两种类型：
       * 类型说明符 (表达式)	//C++风格
       * (类型说明符) 表达式     //C语言风格
       
     * 四种类型转换操作符：
         * static_cast：
     
             * 作用：将一种基本类型数据转换为另一种基本类型数据：
     
             * 特点：基于内容的转换；安全、确定；
     
             * 语法形式：
     
                 ```C++
                 新类型 表达式 = static_cast<旧类型>(表达式);
                 ```
             
           * 举例：
           
           ```C++
           int i = 2;
           float x = static_cast<int>(i);
           // 基于内容的转换：将i的整形二进制表示转化为浮点型二进制表示
           ```
           
         * reinterpret_cast<类型说明符>(表达式)：
     
             * 作用：将一种类型的指针转换为另一种类型的指针；
     
                 (新类型的指针可以和旧类型的指针毫无关系)
     
             * 特点：危险、不确定；没有必要不要用；
     
             * 语法形式：
             
                 ```C++
                 新类型* 表达式 = reinterpret_cast<旧类型*>(表达式);
                 ```
             
             * 举例：
           
             ```C++
             int i = 2;
             float* pf = reinterpret_cast<float *>(&i);
             // 无论是int类型的指针，还是float类型的指针，存储的都是同一个地址；
             // 它们的区别在于：相应地址中的数据被解释为不同的类型；
             ```
           
         * const_cast：
     
             * 作用：将数据类型中的const属性去除；
     
                 (可以将常指针转换为普通指针，将常引用转换为普通引用；但将常对象转换为普通对象无意义，因为对象的转换会生成对象的副本)
     
             * 特点：
     
             * 语法形式：
     
             * 举例：
     
                 ```C++
                 void func(const int* cp)
                 {
                     int* p = const_cast<int*>(cp);
                     (*p)++;
                 }
                 ```
     
         * dynamic_cast：
     
           * 作用：判断指针在运行时所指对象的确切类型，并完成相应的转换；(继承关系中)
     
           * 特点：
     
           * 举例：
     
               ```C++
               class Base
               {
                   ...
               };
               
               class Derived: public Base
               {
               	...
               };
               
               Base* pb1 = new Base();
               Base* pb2 = new Derived();
               
               Derived* pd1 = dynamic_cast<Derived*>(pb1);		// failed
               Derived* pd2 = dynamic_cast<Derived*>(pb2);		// succeed
               ```
     
     * Note：
     
         * 显示转换可能是不安全的(由高类型向低类型转换会损失数据的精度)；
         * 显示转换是暂时的，一次性的，原有值并不会被改变；
     



### 2.3.6 语句

1. 分类：
   * 空语句：一个独立的";"就构成一个空语句，空语句不产生任何操作；
   * 声明语句：变量的声明；
   * 表达式语句：在表达式末尾加一个";"；
   * 选择语句：if..else..., switch
   * 循环语句：for, while, do while
   * 跳转语句：go to
   * 复合语句：多个语句用一个大括号包围；
   * 标号语句：
2. Note(表达式与表达式语句的不同)：
   * 一个表达式可以作为另一个更复杂的表达式的一部分，继续参与运算；
   * 表达式语句则不能；



## 2.3 数据的输入与输出



### 2.3.1 I/O流

1. cin 用来处理标准输入(键盘输入)
2. cout 用来处理标准输出(屏幕输出)



### 2.3.2 预定义的插入符和提取符

1. << 预定义插入符：可串联多个插入符，输出多个数据项；
2. \>> 预定义提取符：可串联多个提取符，输入多个数据项；



### 2.3.3 简单的I/O格式控制

1. C++的I/O流类库提供了一些操作符，可以直接嵌入到输入输出语句中来实现I/O格式控制；(参考书P.38 表2-6)

   ```C++
   cout << setw(5) << setprecision(3) << 3.1415 << endl;
   // 输出浮点数3.1415并换行，设置域宽为5个字符，小数点后保留两位有效数字
   ```

2. 要使用操纵符，必须在源程序开头包含\<iomanip>头文件；(manipulator，操纵符)



## 2.4 算法的基本控制结构

1. 算法的基本控制结构有三种：顺序、选择、循环；



### 2.4.1 用if语句实现选择结构

1. 语法形式：

   ```c++
   if(表达式1)
   	语句1;
   else
       语句2;
   ```

2. Note：

   * 语句不仅可以是一条语句，也可以是一个大括号括起来的复合语句；
   * 当语句2为空时，else可以省略；

3. 程序实例：

   ```C++
   // 2_2.cpp
   /*
   	功能：判断一个年份是否是闰年
   	思路：闰年的年份可以被4整除而不能被100整除，或者能被400整除
   */
   
   #include <iostream>
   using namespace std;
   
   int main(int argc, char* argv[])
   {
       int year;
       bool isLeapYear;
       
       cout << "Enter the year: " << endl;
       cin >> year;
       isLeapYear = ((year%4 == 0 && year%100 != 0) || (year%400 == 0));
       
       if(isLeapYear)
           cout << year << "is a leap year" << endl;
       else
           cout << year << "is not a leap year" << endl;
       
       return 0;
   }
   ```



### 2.4.2 多重选择结构

1. 嵌套的if语句：

   * 语法形式：

     ```c++
     if(表达式1)
         if(表达式2)
             语句1
         else
         	语句2
     else
     	if(表达式3)
             语句3
         else
         	语句4
     ```

   * Note :
     * 语句1,2,3,4可以是复合语句；
     * 每层的if要与else配对，如果省略了某个else，要用{}括起来该层的if语句来确定层次关系；
     * 注意悬挂if引起的歧义：(else总是和它之前最近的一个if结合)
     
   * 程序实例：

       ```C++
       // 2_3.cpp
       
       #include <iostream>
       using namespace std;
       
       int main(int argc, char* argv[])
       {
           int x, y;
           cout << "Enter x and y: " << endl;
           cin << x << y;
           
           if(x != y)
           {
               if(x > y)
                   cout << "x > y" << endl;
               else
                   cout << "x < y" << endl;
           }
           else
               cout << "x = y" << endl;
           
           return 0;
       }
       ```

2. if ... else if 语句：

   * 如果if语句的嵌套都是发生在else分支中，就可以用if...else if语句；

3. switch 语句：

   * 适用于：在有的问题中虽然需要进行多次判断选择，但每次判断的都是同一表达式的值；

   * 语法形式：

     ```C++
     switch(表达式)
     {
         case 常量表达式1 : 语句1;
         ...
         case 常量表达式n : 语句n;
         default : 语句n+1;
     }
     ```

   * 执行顺序：

       * 首先计算"表达式"的值，然后在case语句中寻找值相等的常量表达式，并以此为入口标号，由此开始顺序执行；
       * 如果没找到相等的常量表达式，则从"default : "开始执行。

   * Note：
     * switch语句后面的表达式可以是整形、字符型、枚举型；
     * 每个常量表达式的值不能相同；
     * 每个case分支可以有多条语句，但不必用{}；
     * 每个case语句只是一个入口标号，并不能确定执行的终点，因此每个case语句最后应该加上break语句，用来结束整个switch结构，否则会从入口点开始一直执行到switch结构的结束点；(灵活使用)
     * 当若干分支需要执行相同的操作时，可以使多个case分支共用一组语句；
     
   * 程序实例：

       ```C++
       // 2_4.cpp
       
       #include <iostream>
       using namespace std;
       
       int main()
       {
           int day;
           cin >> day;
           
           switch(day)
           {
               case 0:
                   cout << "Sunday" << endl;
                   break;
               case 1:
                   cout << "Monday" << endl;
                   break;
               case 2:
                   cout << "Tuesday" << endl;
                   break;
               case 3:
                   cout << "Wednesday" << endl;
                   break;
               case 4:
                   cout << "Thursday" << endl;
                   break;
               case 5:
                   cout << "Friday" << endl;
                   break;
               case 6:
                   cout << "Saturday" << endl;
                   break;
               default:
                   cout << "Day out of range Sunday ... Saturday" << endl;
                   break;
           }
           
           return 0;
       }
       ```



### 2.4.3 循环结构

1. while语句：
   * 语法形式：while(表达式) 语句；
   
   * 执行顺序：先判断表达式的值，若为true，再执行循环体；若为false，循环结束；

   * Note： 在循环体中，应该包含改变循环条件表达式的语句，否则便会陷入死循环；
   
   * 程序实例：
   
       ```C++
       // 2_5.cpp	求自然数1-10之和
       
       #include <iostream>
       using namespace std;
       
       int main()
       {
           int i = 1, sum = 0;
           while(i <= 10)
           {
               sum += i;
               i++;
           }
           
           cout << "sum = " << sum << endl;
           return 0;
       }
       ```
   
2. do ... while语句
   * 语法形式：do 语句 while (表达式);
   
   * 执行顺序：先执行循环体，再判断表达式，若为true，再执行循环体；若为false，循环结束；

   * Note： 在循环体中，应该包含改变循环条件表达式的语句，否则便会陷入死循环；
   
   * 程序实例：
   
       ```C++
       // 2_6.cpp	输入一个整数，将各位数字反转后输出(leetcode 7)
       
       #include <iostream>
       using namespace std;
       
       int main()
       {
           int n, right_digit, newnum = 0;
           cout << "Enter the number: " << endl;
           cin >> n;
           
           cout << "The number in reverse order is: " << endl;
           do
           {
               right_digit = n%10;
               cout << right_digit;
               n /= 10;
           } while(n != 0);
           cout << endl;
           
           return 0;
       }
       ```
   
       ```C++
       // 2_7.cpp
       
       #include <iostream>
       using namespace std;
       
       int main()
       {
           int i = 1, sum = 0;
           do
           {
               sum += i;
               i++;
           } while(i <= 10);
           cout << "sum = " << sum << endl;
           
           return 0;
       }
       ```
   
       
   
3. for 语句

   * 作用：既可以用于循环次数确定的情况，也可以用于循环次数未知的情况；(包含了while语句的功能)

   * 语法形式：

       ```C++
   for(初始语句; 表达式1; 表达式2)
       {
   	 	循环体;
       }
       ```
* 执行流程：
  
   * 先执行初始语句；
   
    * 然后计算表达式1的值。若为false，退出循环；若为true，执行一次循环体，然后计算表达式2的值，再计算表达式1的值；
   
* Note :
  
  * 初始语句，表达式1，表达式2，都可以省略，分号不能省略；
  
     ```C++
      for( ; ;)		//相当于while(true)
     ```
     
   * 表达式1是循环控制条件，如果省略，循环将无终止地进行下去；一般在循环控制条件中包含一个在循环过程中会不断变化的变量，称之为循环变量；
  
     ```C++
     for(int i = 0; i < 100; i++) sum += i;		// i就是循环控制变量
     ```
  
   * 初始语句可以是表达式语句或声明语句；
     
     * 若为表达式语句，可以是简单的表达式，也可以是逗号表达式；
     
       ```C++
     int i, j;
       for(i = 0, j = 100; i <= j; i++, j--) k = i + j;
     ```
       
     * 若为声明语句，可以包含多个变量的声明；
     
       ```C++
     for(int i = 0, j = 100; i <= j; i++, j--) k = i + j;
       ```
     
     * 推荐写法：
     
       ```C++
     //这种方式定义的变量只在循环内部有效，用途专一而明确
       for(int i = 0; i < iMax; i++)
     {
           ...
       }
       ```
   * 程序实例：
  
       ```C++
       // 2_8.cpp 	输入一个整数，求出它所有的因子
       
       #include <iostream>
       using namespace std;
       
       int main()
       {
           int n;
           
           cout << "Enter a positive integer: " << endl;
           cin >> n;
           cout << "Number " << n << " Factors: " << endl;
           
           for(int k = 1; k <= n; k++)
               if(n%k == 0)
                   cout << k << " ";
           cout << endl;
           
           return 0;
       }
       ```



### 2.4.4 循环结构与选择结构的嵌套

1. 选择结构的嵌套

   * 嵌套的选择结构可以实现多重选择；

2. 循环结构的嵌套

   ......

3. 循环结构与选择结构相互嵌套

   ......



### 2.4.5 其他控制语句

1. break：
   * 出现在switch或循环体中，使程序从循环体或switch语句内跳出，继续执行逻辑上的下一条语句；
   * break不宜用在别处；
2. continue：
  
   * 用在循环体中，结束本次循环，接着判断是否执行下一次循环；
3. goto：
   * 语法形式：
   
       ```C++
       goto 语句标号；
       ```
   
   * 语句标号：放在语句的最前面，并用(:)与语句分开。是用来标识语句的标识符；
   
   * Note：会破坏程序的结构，应该不用或少用；



## 2.5 自定义数据类型

### 2.5.1 typedef声明

1. 作用：为一个已有数据类型另外命名，有利于提高程序可读性；

2. 语法形式：

   ```C++
   typedef 已有类型名 新类型名列表;
   ```

3. 程序实例：

   ```C++
   typedef double Area, Volumn;
   Area a;
   Volumn v;
   ```



### 2.5.2 枚举类型

1. 定义：将变量的可取值一一列举出来，便构成了一个枚举类型。

2. 语法形式： 

   ```C++
   enum 枚举类型名 {变量值列表};
   ```

3. 举例：

   ```C++
   enum Weekday {SUN, MON, TUE, WED, THU, FRI, SAT};
   ```

4. Note：

   * 对枚举元素按照常量处理，不能赋值；

       ```C++
       SUN = 0; 	// SUN是枚举元素，此语句非法
       ```

   * 枚举元素有默认值，依次为：0,1, 2, …。也可在声明时另行定义枚举元素的值；

       ```C++
       enum Weekday {SUN=7, MON=1, TUE, WED, THU, FRI, SAT};
       ```

   * 枚举值可以进行关系运算；

   * 枚举类型数据可以隐式转换为整形数据，而整形数据到枚举类型数据的转换，则需要采用显示转换的方式(强制类型转换)；

   * C++中声明完枚举类型后，声明变量时，可以使用关键字enum，也可以不使用关键字enum；

5. 程序实例：

   ```C++
   // 2_11.cpp
   
   #include <iostream>
   using namespace std;
   
   enum GameResult {WIN, LOSE, TIE, CANCEL};
   
   int main()
   {
       GameResult result;					// 声明变量时，可以不使用关键字enum
       enum GameResult omit = CANCEL;		// 也可以使用关键字enum
       
       for(int count = WIN; count <= CANCEL; count++)		// 枚举型转换为整形(隐式转换)
       {
           // result = static_cast<GameResult>(count);
           result = GameResult(count);						// 整形转换为枚举型(显式转换)
           if(result == omit)
               cout << "The game was cancelled." << endl;
           else
           {
               cout << "The game was played" << endl;
               if(result == WIN)
                   cout << " and we won." << endl;
               else if(result == LOSE)
                   cout << " and we lose." << endl;
               cout << endl;
           }
       }
       
       return 0;
   }
```
   



## 2.6 深度探索

### 2.6.1 变量的实现机制

1. C++中使用变量名的原因？
    * C++中不同的变量名对应内存中不同的地址，C++依靠地址来区别不同的变量；
2. 为什么需要对不同的数据类型加以区分？
    * 任何类型的数据，在内存中都是以二进制形式存储的；
    * 一串二进制数只有与特定的数据类型关联后，才有意义；
    * 源代码中为变量规定的数据类型，通过编译器在编译各个具体操作时选择的指令来体现在目标代码中的；
    * CPU所执行的指令并不对操作数的类型加以区分，编译器需要根据变量的类型选择适当的指令；
3. 为什么变量只有先声明才能使用？
    * 只有变量的类型确定后，它所参与的每个表达式才有意义；



### 2.6.2 表达式的执行原理

1. 寄存器：寄存器在CPU内部，读写速度非常快，CPU的大部分读写操作都是对寄存器进行的；
2. C++表达式只能一步步地执行，每次只能执行一次运算；(借助寄存器)