[TOC]



# 第三章 处理机调度与死锁

**【当前OS广泛采用抢占式优先级调度算法】**



## 3.1 处理机调度的层次和调度算法的目标

### 3.1.1 处理机的调度层次

1. 高级调度(High Level Scheduling)：又称作业调度
   * 调度对象：作业
   * 主要功能：根据某种算法，决定将外存中处于后备队列中的哪几个作业调入内存；
   * 用于：多道批处理系统 (在分时和实时系统中，作业直接进入内存，无需设置作业调度)
2. 低级调度(Low Level Scheduling)：又称进程调度
   * 调度对象：进程
   * 主要功能：根据某种算法，决定就绪队列中哪个进程获得处理机；
   * 用于：多道批处理、分时、实时系统都必须配置 (因为进程是调度的基本单位)
3. 中级调度(Intermediate Scheduling)：又称内存调度
   * 目的：提高内存的利用率和系统吞吐量
   * 做法：将内存中暂时不能运行的进程，调至外存等待，即挂起(Suspend)；将外存中已具备运行条件的进程，在内存有空闲时，调入内存，即激活(Active)；
   * 实质：存储器管理中的对换功能；



### 3.1.2 处理机调度算法的目标

1. 共同目标：
   * 利用率：提高资源的利用率；
     * CPU利用率 = CPU有效工作时间/(CPU有效工作时间 + CPU空闲等待时间)​
   * 公平性：使诸进程都获得合理的CPU时间；
   * 平衡性：保证系统资源使用的平衡；
   * 策略强制执行：
2. 批处理系统的目标：
   * 周转时间：(作业从提交到完成的时间)
     * 分类：
       * 平均周转时间：
       * 平均带权周转时间：
     * 要求：
         * 平均周转时间短；
   * 系统吞吐量：(单位时间内系统所完成的作业数)
     * 要求：
         * 系统吞吐量大(对短作业有利，短作业执行时间短)；
   * 处理机利用率：
     * 要求：
         * 处理机利用率高(对长作业有利，长作业不需要频繁切换)；
3. 分时系统的目标：
   * 响应时间快：
     * 响应时间 = 等待时间 + 服务时间；
   * 均衡性：
     * 系统响应时间的快慢应与用户请求的复杂性相适应；
4. 实时系统的目标：
   * 截止时间的保证：
     * 截止时间：指某任务必须开始执行的最迟时间，或必须完成的最迟时间；
   * 可预测性：



## 3.2 作业与作业调度

### 3.2.1 批处理系统中的作业

1. 作业和作业步：
   * 作业(Job)：不仅包含程序和数据，还包含作业说明书(系统根据作业说明书来控制程序的运行)；
   * 作业步(Job Step)：作业运行期间，每一个相对独立的步骤；
2. 作业控制块JCB(Job Control Block)：
   * 类似于PCB、TCB
3. 作业运行的三个阶段和三种状态：
   * 收容阶段(后备状态)：从输入到存入外存中的后备队列；
   * 运行阶段(运行状态)：从第一次进入就绪状态到运行结束前；
   * 完成阶段(完成状态)：运行结束时；



### 3.2.2 作业调度的主要任务

1. 接纳多少个作业：
   * 取决于多道程序度(Degree of Multiprogramming)
   * 对系统来说，希望装入较多的作业，有利于提高CPU利用率和系统吞吐量；
   * 对内存来说，运行的作业太多时，进程在运行时因内存不足所发生的中断就会急剧增加，平均周转时间变长，服务质量下降；
2. 接纳哪些作业：
   * 取决于作业调度算法



### 3.2.3 作业调度算法

**实质都是基于优先级原则**

1. 先来先服务FCFS(First Come First Served)

   * 以作业的等待时间为优先级，等待时间越长，优先级越高；

2. 短作业优先SJF(Short Job First)

   * 以作业的运行时间为优先级，运行时间越短，优先级越高；

3. 优先级调度算法PSA(Priority-scheduling algorithm)

   * 基于作业的紧迫程度，由外部赋予优先级；

4. 高响应比优先HRRN(Hightest Response Ratio Next)

   * 做法：

     * 引入一个动态优先级(随等待时间延长而增加)：

       ​	$优先权 = (等待时间 + 要求服务时间) / 要求服务时间$；

     * 其中：

       ​	$响应时间 = 等待时间 + 要求服务时间$

     * 所以：

       ​	$响应比 = 响应时间 / 要求服务时间 = 优先权$

   * 优点：既考虑了作业的等待时间，又考虑了作业的运行时间，实现了较好的折中；

   * 缺点：每次进行调度前，都需要先计算优先权，会增加系统开销；



## 3.3 进程调度

### 3.3.1 进程调度的任务、机制、方式

1. 任务：
   * 保存处理机的现场信息；
   * 按照某种算法选取进程；
   * 把处理机分配给进程；
2. 机制(三个基本部分)：
   * 排队器：将所有的就绪队列按照一定的策略排成一个或多个队列(以便调度程序能更快地找到)；
   * 分派器：执行调度算法；
   * 上下文切换器：保存当前进程的上下文，装入分派进程的上下文；
3. 方式：
   * 非抢占方式(Nonpreemptive Mode)：
     * 调度机制：一旦把处理机分配给某进程后，就一直运行下去直至完成，或因该进程发生某事件而放弃处理机时，才将处理机分配给其他进程；
     * 优点：实现简单、开销小、适用于多道批处理系统；
     * 缺点：不适用于分时、实时系统；
   * 抢占方式(Preemptive Mode)：
     * 调度机制：允许调度程序根据某种原则，去暂停某个正在执行的进程，将处理机分配给另外的进程；
     * 优点：能满足分时、实时、多道批处理系统的需求；
     * 缺点：实现复杂、开销大；
     * 原则：时间片原则、优先级原则、公平原则；



### 3.3.2 基于时间片原则的调度算法

1. 轮转调度(RR)算法：
   * 隐含假设：系统中所有进程的紧迫性相同。
   * 基本原理：
     
     * 基于时间片的轮转(Round Robin)，即让就绪队列中的每个进程按照FCFS，每次仅运行一个时间片。
   * 进程切换时机：
     * 时间片用完；
     * 进程运行完成；
     * 因某事件阻塞(如IO等)；
   * 时间片大小的确定：
     
     * **时间片大小略大于一次典型的交互所需要的时间**
     
         (使大多数交互式进程能在一个时间片内完成，从而获得很小的响应时间)



### 3.3.3 基于优先级原则的调度算法

1. 优先级调度算法：
   * 问题：系统中进程的紧迫性不同。
   * 优先级调度算法的类型：
     * 非抢占式优先级调度算法：
     * 抢占式优先级调度算法：
   * 优先级的类型：
     * 静态优先级：在创建进程时确定，并在进程运行期间不变；
     * 动态优先级：随进程的运行而变化；
2. 多队列调度算法：
   * 调度机制：将进程就绪队列从一个拆分为多个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同就绪队列本身也可以设置不同的优先级；
   * 优点：可以针对不同的用户请求，提供多种调度策略；
3. **多级反馈队列调度算法(multileveled feedback queue)：**
   * 调度机制：
     * 设置多个就绪队列，为每个队列赋予不同的优先级(第一个队列的优先级最高)。为不同队列中的进程赋予的执行时间片的大小也各不相同(优先级高的队列中，其时间片越小)；
     * 每个队列都采用FCFS算法，最后一个队列采用RR算法(在当前时间片未运行完成的进程，调入下一个队列中继续运行)；
     * 按队列优先级调度(仅当前(i-1)个队列都为空时，第i个队列中的进程才能运行)；
   * 调度算法的性能
     * 若规定第一个队列的时间片略大与大多数人机交互所需的处理时间时，能较好地满足各类用户需求；



### 3.3.4 基于公平原则的调度算法

1. 保证调度算法：
   * 针对进程，保证分配给每个进程相同的CPU时间；
2. 公平分享调度算法：
   * 针对用户，保证分配给每个用户相同的(或所要求的)CPU时间；



## 3.4 实时调度

**【通常的优先级调度不能适用于实时系统】**



### 3.4.1 实现实时调度的基本条件

1. 提供必要的信息
   * 就绪时间
   * 开始截止时间和完成截止时间
   * 处理时间
   * 资源要求
   * 优先级
2. 系统处理能力强
3. 采用抢占式调度机制
4. 具有快速切换机制
   * 对中断的快速响应能力；
   * 快速的任务分派能力；



### 3.4.2 实时调度算法的分类

1. 非抢占式调度算法
   * 非抢占式轮转调度算法(响应时间：数秒到数十秒)
   * 非抢占式优先调度算法(响应时间：数百毫秒至数秒)
2. 抢占式调度算法：
   * 基于时钟中断的抢占式优先级调度算法(响应时间：几毫秒至几十毫秒)
   * 立即抢占(Immediate Preemption)的优先级调度算法(响应时间：100微妙至几毫秒)



### 3.4.3 最早截止时间优先EDF(Earliest Deadline First)算法

1. 优先级：根据任务的截止时间确定，截止时间越早，优先级越高；
2. 用途：非抢占式调度 & 抢占式调度
3. 分类：
   * 非抢占式调度方式用于非周期实时任务(参考书中例子)
   * 抢占式调度方式用于周期实时任务(参考书中例子)



### 3.4.4 最低松弛度优先LLF(Least Laxity First)算法

1. 优先级：

   * 根据任务的紧急(松弛)程度确定，松弛度越低，优先级越高；
   * 松弛度为0时，意味着必须开始执行；

2. 松弛程度：

   * 松弛程度 = 完成截止时间 - 运行时间 - 当前时间；

3. 用途：抢占式调度；

4. 例子：(参考书)



### 3.4.5 优先级倒置(priority inversion problem)

1. 优先级倒置的形成：
   * 概述：高优先级进程被低优先级进程延迟或阻塞；
   * 原因：由于共享临界资源，高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞；
   * 例子：(参考书)
2. 优先级倒置的解决办法：
   * 简单方法：低优先级进程进入临界区后，其所占用的处理机就不允许被抢占；
   * 实用方法：(建立在动态优先级基础上)当高优先级进程P1进入临界区，去使用临界资源R，如果有一个低优先级进程P3正在使用该资源，此时一方面P1被阻塞，另一方面P3继承P1的优先级，并一致保持直至P3退出临界区；



## 3.5 死锁概述

### 3.5.1 资源问题

1. 可重用性资源 & 消耗性资源
   * 可重用性资源：
     * 定义：(进程在运行期间)数目固定；不能创建和删除；
     * 实例：设备、文件、信号量
   * 消耗性资源：
     * 定义：(进程在运行期间)数目不断变化；能创造和消耗；
     * 实例：用于进程间通信的消息

2. 可抢占性资源 & 不可抢占性资源(**可抢占性资源不会引起死锁，而不可抢占性资源会引起死锁**)

   * 可抢占性资源：

     * 定义：指某进程获得后，其他进程还能抢占的这类资源；

     * 实例：CPU、主存

   * 不可抢占性资源：

     * 定义：指某进程获得后，其他进程不能抢占的这类资源；
     * 实例：刻录机、磁带机、打印机



### 3.5.2 死锁的起因

1. 竞争不可抢占性资源：
   * 实例：共享文件时的死锁
2. 竞争可消耗性资源：
   * 实例：进程之间通信时的死锁
3. 进程推进顺序不当：



### 3.5.3 死锁的定义、必要条件、处理方法

1. 定义：

   * 如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的(Deadlock)；
   * (死锁描述的是一组进程的状态)

2. 必要条件：(**产生死锁必须同时具备以下四个条件**)

   * 互斥条件：进程对所分配到的资源进行排它性使用；
   * 请求和保持条件：已获得资源的进程，在请求新资源但被阻塞时，不释放已获得的资源；
   * 不可抢占条件：进程已获得的资源在未使用完之前不能被抢占，只能在使用完时由自己释放；
   * 循环等待条件：存在一个进程-资源的循环链；

3. 处理方法：

   1. 预防死锁：通过设置某些限制条件，去破坏产生死锁四个必要条件的一个或几个来预防死锁；
   2. 避免死锁：在资源的动态分配过程中，用某种方法预防系统进入不安全状态；
   3. 检测死锁：通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来；
   4. 解除死锁：撤销一些进程，并回收它们的资源，交由其他进程使用；

   **从1到4对死锁的防范程度逐渐减弱，但资源利用率逐渐提高，进程因资源因素而阻塞的频度下降。**



## 3.6 预防死锁

​	互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证。



### 3.6.1 破坏“请求和保持”条件

1. 原则：当一个进程在请求资源时，它不能持有不可抢占资源；

2. 协议：
   * 第一种：
     - 规定：所有进程，必须一次性地申请和释放其所需的所有资源；
     - 优点：简单、易行、安全；
     - 缺点：资源利用率低；进程经常发生饥饿现象；
   * 第二种：
     * 规定：允许一个进程只获得运行初期所需的资源后，便开始运行，运行过程中再逐步释放已用毕的资源，然后请求新的所需资源；
     * 优点：提高资源利用率；减少进程发生饥饿的概率；



### 3.6.2 破坏“不可抢占”条件

1. 规定：当一个已保持了某些不可抢占资源的进程，提出新的资源请求而不能得到满足时，必须释放已拥有的所有资源；
2. 缺点：实现复杂；需付出很大的代价；



### 3.6.3 破坏“循环等待”条件

1. 方法：
   1. 对系统所有资源类型进行线性排序，并赋予不同的序号；
   2. 规定每个进程必须按照序号递增的顺序请求资源；
   3. 如果需要多个同类资源单元，必须一起申请；
   4. 如果某进程已经拥有高序号的资源，当其想要申请一个低序号的资源时，必须先释放所有具有相同或更高序号的资源后，才能申请低序号资源；

2. 如何规定每种资源的序号：

​	根据大多数进程所需资源的先后顺序(输入设备低序号，输出设备高序号)

3. 优点：
   * 资源利用率和系统吞吐量明显提高；
   * 缺点：
     * 为系统中各类资源所规定的序号必须相对稳定，限制了新类型设备的增加；
     * 作业使用资源的顺序与系统规定的顺序不同，造成资源浪费；
     * 会限制用户简单自主地编程；



## 3.7 避免死锁

做法：在资源动态分配的过程中，防止系统进入不安全状态，以避免死锁发生；

优点：施加的限制条件弱，可获得较好的系统性能**(目前常用此方法避免死锁)**



### 3.7.1 系统安全状态

1. 安全状态：指系统能按某种进程推进顺序(P1, P2, P3, ..., Pn)为每个进程Pi分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利地完成。此时称(P1, P2, ..., Pn)为安全序列；
2. 不安全状态：如果系统无法找到一个安全序列，则称系统处于不安全状态；
3. **并非所有的不安全状态都必然会转为死锁状态，但只要系统处于安全状态，系统便不会进入死锁状态**；
4. 避免死锁的基本思想：确保系统始终处于安全状态；



### 3.7.2 利用银行家算法避免死锁

起源：Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况；



1. 银行家算法中的数据结构(可利用的资源、所有进程对资源的最大需求、系统中的资源分配、进程还需资源)

   * 可利用资源向量Available：m
   * 最大需求矩阵Max：n*m
   * 分配矩阵Allocation：n*m
   * 需求矩阵Need：n*m

2. 银行家算法：

   (参考书)

3. 安全性算法：

   (参考书)

4. 实例：

   (参考书)



## 3.8 死锁的检测与解除

### 3.8.1 死锁的检测

1. 资源分配图(Resource Allocation Graph)

   * 定义和限制：(参考书)

2. 死锁定理

   * 简化方法：

     * 在资源分配图中，找到一个既不阻塞又非独立的进程节点$P_i$，开始逐个去边；

     * 若能使所有的进程节点都成为孤立节点，则该图是可完全简化的，否则是不可完全简化的；

       **(所有的简化顺序都将得到相同的不可简化图)**

   * 死锁定理：

     * **S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。**

3. 死锁检测中的数据结构(类似于银行家算法中的数据结构)

   * (参考书)



### 3.8.2 死锁的解除

1. 两种方法：抢占资源；终止进程；
2. 终止进程的方法：

   * 终止所有死锁进程：简单但代价大；
   * 逐个终止进程：较为温和；
3. 付出代价最小的死锁解除算法：
   * 做法：在每一层中找到所有终止代价最小的进程；
   * 缺点：花费的代价很大；
   * 评价：不实际(理想很丰满，现实很骨感)
